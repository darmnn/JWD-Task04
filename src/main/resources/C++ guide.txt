 Аннотация: С++ – это универсальный язык программирования, задуманный так, чтобы сделать программирование более приятным для серьезного программиста. За исключением второстепенных деталей С++ является надмножеством языка программирования C. Помимо возможностей, которые дает C, С++ предоставляет гибкие и эффективные средства определения новых типов. Используя определения новых типов, точно отвечающих концепциям приложения, программист может разделять разрабатываемую программу на легко поддающиеся контролю части. Такой метод построения программ часто называют абстракцией данных. Информация о типах содержится в некоторых объектах типов, определенных пользователем. Такие объекты просты и надежны в использовании в тех ситуациях, когда их тип нельзя установить на стадии компиляции. Программирование с применением таких объектов часто называют объектно-ориентированным. При правильном использовании этот метод дает более короткие, проще понимаемые и легче контролируемые программы. 
 Ключевым понятием С++ является класс. Класс – это тип, определяемый пользователем. Классы обеспечивают сокрытие данных, гарантированную инициализацию данных, неявное преобразование типов для типов, определенных пользователем, динамическое задание типа, контролируемое пользователем управление памятью и механизмы перегрузки операций. С++ предоставляет гораздо лучшие, чем в C, средства выражения модульности программы и проверки типов. В языке есть также усовершенствования, не связанные непосредственно с классами, включающие в себя символические константы, inline-подстановку функций, параметры функции по умолчанию, перегруженные имена функций, операции управления свободной памятью и ссылочный тип. В С++ сохранены возможности языка C по работе с основными объектами аппаратного обеспечения (биты, байты, слова, адреса и т.п.). Это позволяет весьма эффективно реализовывать типы, определяемые пользователем. 
 С++ и его стандартные библиотеки спроектированы так, чтобы обеспечивать переносимость. Имеющаяся на текущий момент реализация языка будет идти в большинстве систем, поддерживающих C. Из С++ программ можно использовать C библиотеки, и с С++ можно использовать большую часть инструментальных средств, поддерживающих программирование на C. 
 Эта книга предназначена главным образом для того, чтобы помочь серьезным программистам изучить язык и применять его в нетривиальных проектах. В ней дано полное описание С++, много примеров и еще больше фрагментов программ.


---------------------------------------------


 Хилл М., Страустрап Б.


 C++



 Предисловие



 Язык формирует наш способ мышления и определяет, о чем мы можем мыслить.

    Б.Л. Ворф

 С++ – это универсальный язык программирования, задуманный так, чтобы сделать программирование более приятным для серьезного программиста. За исключением второстепенных деталей С++ является надмножеством языка программирования C. Помимо возможностей, которые дает C, С++ предоставляет гибкие и эффективные средства определения новых типов. Используя определения новых типов, точно отвечающих концепциям приложения, программист может разделять разрабатываемую программу на легко поддающиеся контролю части. Такой метод построения программ часто называют абстракцией данных. Информация о типах содержится в некоторых объектах типов, определенных пользователем. Такие объекты просты и надежны в использовании в тех ситуациях, когда их тип нельзя установить на стадии компиляции. Программирование с применением таких объектов часто называют объектно-ориентированным. При правильном использовании этот метод дает более короткие, проще понимаемые и легче контролируемые программы. Ключевым понятием С++ является класс. Класс – это тип, определяемый пользователем. Классы обеспечивают сокрытие данных, гарантированную инициализацию данных, неявное преобразование типов для типов, определенных пользователем, динамическое задание типа, контролируемое пользователем управление памятью и механизмы перегрузки операций. С++ предоставляет гораздо лучшие, чем в C, средства выражения модульности программы и проверки типов. В языке есть также усовершенствования, не связанные непосредственно с классами, включающие в себя символические константы, inline-подстановку функций, параметры функции по умолчанию, перегруженные имена функций, операции управления свободной памятью и ссылочный тип. В С++ сохранены возможности языка C по работе с основными объектами аппаратного обеспечения (биты, байты, слова, адреса и т.п.). Это позволяет весьма эффективно реализовывать типы, определяемые пользователем. С++ и его стандартные библиотеки спроектированы так, чтобы обеспечивать переносимость. Имеющаяся на текущий момент реализация языка будет идти в большинстве систем, поддерживающих C. Из С++ программ можно использовать C библиотеки, и с С++ можно использовать большую часть инструментальных средств, поддерживающих программирование на C. Эта книга предназначена главным образом для того, чтобы помочь серьезным программистам изучить язык и применять его в нетривиальных проектах. В ней дано полное описание С++, много примеров и еще больше фрагментов программ.




 Благодарности


 С++ никогда бы не созрел без постоянного использования, предложений и конструктивной критики со стороны многих друзей и коллег. Том Карджилл, Джим Коплин, Сту Фельдман, Сэнди Фрзер, Стив Джонсон, Брайэн Керниган, Барт Локанти, Дуг МакИрой, Дэннис Риччи, Лэрри Рослер, Джерри Шварц и Джон Шопиро подали важные для развития языка идеи. Дэйв Пресотто написал текущую реализацию библиотеки потоков ввода/вывода.
 Кроме того, в развитие С++ внесли свой вклад сотни людей, которые присылали мне предложения по усовершенствованию, описания трудностей, с которыми они сталкивались, и ошибки компилятора. Здесь я могу упомянуть лишь немногих из них: Гэри Бишоп, Эндрю Хьюм, Том Карцес, Виктор Миленкович, Роб Мюррэй, Леони Росс, Брайэн Шмальт и Гарри Уокер
 В издании этой книги мне помогли многие люди, в частности, Джон Бентли, Лаура Ивс, Брайэн Керниган, Тэд Ковальски, Стив Махани, Джон Шопиро и участники семинара по С++, который проводился в Bell Labs, Колумбия, Огайо, 26-27 июня 1985 года.
 Мюррэй Хилл, Нью Джерси Бьярн Страустрап




 Заметки для Читателя



 «О многом,» – молвил Морж, – «Пришла пора поговорить.»

    Л. Кэррол

 В этой главе содержится обзор книги, список библиографических ссылок и некоторые замечания по С++ вспомогательного характера. Замечания касаются истории С++, идей, оказавших влияние на разработку С++, и мыслей по поводу программирования на С++. Эта глава не является введением: замечания не обязательны для понимания последующих глав, и некоторые из них предполагают знание С++.




 Структура Этой Книги


 Глава 1 – это короткое турне по основным особенностям С+ +, предназначенное для того, чтобы дать читателю почувствовать язык. Программисты на C первую половину главы могут прочитать очень быстро, она охватывает главным образом черты, общие для C и С++. Во второй главе описаны средства определения новых типов в С++, начинающие могут отложить более подробное изучение этого до того, как прочтут Главы 2, 3 и 4.
 В Главах 2, 3 и 4 описываются средства С++, не входящие в определение новых типов: основные типы, выражения и структуры управления в С++ программах. Другими словами, в них описывается подмножество С++, которое по существу является языком C. Рассмотрение в них проводится гораздо подробнее, но полную информацию можно найти только в справочном руководстве.
 В Главах 5, 6 и 7 описываются средства С++ по описанию новых типов, особенности языка, не имеющие эквивалента в C. В Главе 5 приводится понятие базового класса, и показывается, как можно инициализировать объекты типа, определяемого пользователем, обращаться к ним и, наконец, убирать их. В Главе 6 объясняется, как для определяемого пользователем типа определять унарные и бинарные операции, как задавать преобразования между типами, определяемыми пользователем, и как как задавать то, каким образом должно обрабатываться каждое создание, уничтожение и копирование значения определяемого пользователем типа. Глава 7 описывает концепцию производных классов, которая позволяет программисту строить более сложные классы из более простых, обеспечивать альтернативные интерфейсы класса и работать с объектами эффективно и с гарантией типа в тех ситуациях, когда типы объектов не могут быть известны на стадии компиляции.
 В Главе 8 представлены классы ostream и istream, предоставляемые стандартной библиотекой для осуществления ввода-ввода. Эта глава имеет двоякую цель: в ней представлены полезные средства, что одновременно является реальным примером использования С++.
 И, наконец, в книгу включено справочное руководство по С++.
 Ссылки на различные части этой книги даются в форме #2.3.4 (Глава 2 подраздел 3.4). Глава с – это справочное руководство например #с.8.5.5.




 Замечания по Реализации


 Во время написания этой книги все реализации С++ использовали версии единственного интерфейсного компилятора*. Он используется на многих архитектурах, включая действующие версии системы операционной системы UNIX на AT amp;T 3B, DEC VAX, IBM 370 и Motorolla 68000. Фрагменты программ, которые приводятся в этой книге, взяты непосредственно из исходных файлов, которые компилировались на 3B в UNIX System V версии 2 [15], VAX11/750 под 8-ой Редакцией UNIX [16] и CCI Power 6/32 под BSD4.2 UNIX [17]. Язык, описанный в этой книге, – это «чистый С++», но имеющиеся на текущий момент компиляторы реализуют большое число «анахронизмов» (описанных в #с.15.3), которые должны способствовать переходу от C к С++.
 – * С++ можно купить в AT amp;T, Software Sales and Marketing, PO Box 25000, Greensboro, NC 27420, USA (телефон 800-828-UNIX) или в ваших местных организациях, осуществляющих продажу Системы UNIX. (прим. автора)




 Упражнения


 Упражнения находятся в конце глав. Все упражнения главным образом типа напишите-программу. Для решения всегда пишите такую программу, которая будет компилироваться и работать по меньшей мере на нескольких тестовых случаях. Упражнения различаются в основном по сложности, поэтому они помечены оценкой степени сложности. Шкала экспоненциальная, так что если на упражнение (*1) вам потребовалось пять минут, то на упражнение (*2) вам может потребоваться час, а на (*3) – день. Время, которое требуется на то, чтобы написать и оттестировать программу, зависит больше от опыта читателя, нежели от самого упражнения. Упражнение (*1) может отнять день, если для того, чтобы запустить ее, читателю сначала придется знакомиться с новой вычислительной системой. С другой стороны, тот, у кого под рукой окажется нужный набор программ, может сделать упражнение (*5) за час. В качестве источника упражнений к Главам 2-4 можно использовать любую книгу по C. У Ахо и др. [1] приведено большое количество общих структур данных и алгоритмов в терминах абстрактных типов данных. Эту книгу также может служить источником упражнений к Главам 5-7. Однако языку, который в этой книге использовался, недостает как функций членов, так и производных классов. Поэтому определяемые пользователем типы часто можно выражать в С++ более элегантно.




 Замечания по Проекту Языка


 Существенным критерием при разработке языка была простота. Там, где возникал выбор между упрощением руководства по языку и другой документации и упрощением компилятора, выбиралось первое. Огромное значение также предавалось совместимости с C, это помешало удалить синтаксис C.
 В С++ нет типов данных высокого уровня и нет первичных операций высокого уровня. В нем нет, например, матричного типа с операцией обращения или типа строка с операцией конкатенации. Если пользователю понадобятся подобные типы, их можно определить в самом языке. По сути дела, основное, чем занимается программирование на С++ – это определение универсальных и специально-прикладных типов. Хорошо разработанный тип, определяемый пользователем, отличается от встроенного типа только способом определения, но не способом использования.
 Исключались те черты, которые могли бы повлечь дополнительные расходы памяти или времени выполнения. Например, мыли о том, чтобы сделать необходимым хранение в каждом объекте «хозяйственной» информации, были отвергнуты. Если пользователь описывает структуру, состоящую из двух 16-битовых величин, то структура поместится в 32-битовый регистр.
 С++ проектировался для использования в довольно традиционной среде компиляции и выполнения, среде программирования на C в системе UNIX. Средства обработки особых ситуаций и параллельного программирования, требующие нетривиальной загрузки и поддержки в процессе выполнения, не были включены в С++. Вследствие этого реализация С++ очень легко переносима. Однако есть полные основания использовать С++ в среде, где имеется гораздо более существенная поддержка. Такие средства, как динамическая загрузка, пошаговая трансляция и база данных определений типов могут с пользой применяться без воздействия на язык.
 Типы и средства сокрытия данных в С++ опираются на проводимый во время компиляции анализ программ с целью предотвращения случайного искажения данных. Они не обеспечивают секретности или защиты от умышленного нарушения правил. Однако эти средства можно использовать без ограничений, что не приводит к дополнительным расходам времени на выполнение или пространства памяти.




 Исторические Замечания


 Безусловно, С++ восходит главным образом к C [7]. C сохранен как подмножество, поэтому сделанного в C акцента на средствах низкого уровня достаточно, чтобы справляться с самыми насущными задачами системного программирования. C, в свою очередь, многим обязан своему предшественнику BCPL [9]. На самом деле, комментарии // (заново) введены в С++ из BCPL. Если вы знаете BCPL, то вы заметите, что в С++ по-прежнему нет VALOF блока. Еще одним источником вдохновения послужил язык Simula67 [2,3], из него была позаимствована концепция класса (вместе с производными классами и функциями членами). Это было сделано, чтобы способствовать модульности через использование виртуальных функций. Возможности С++ по перегрузке операций и свобода в расположении описаний везде, где может встречаться оператор, похожи на Алгол68 [14].
 Название С++ – изобретение совсем недавнее (лета 1983-его). Более ранние версии языка использовались начиная с 1980-ого и были известны как «C с Классами». Первоначально язык был придуман потому, что автор хотел написать событийно управляемые модели для чего был бы идеален Simula67, если не принимать во внимание эффективность. «C с Классами» использовался для крупных проектов моделирования, в которых строго тестировались возможности написания программ, требующих (только) минимального пространства памяти и времени на выполнение. В «C с Классами» не хватало перегрузки операций, ссылок, виртуальных функций и многих деталей. С++ был впервые введен за пределами исследовательской группы автора в июле 1983го. Однако тогда многие особенности С++ были еще не придуманы.
 Название С++ выдумал Рик Масситти. Название указывает на эволюционную природу перехода к нему от C. «++» – это операция приращения в C. Чуть более короткое имя C+ является синтаксической ошибкой, кроме того, оно уже было использовано как имя совсем другого языка. Знатоки семантики C находят, что С++ хуже, чем ++C. Названия D язык не получил, поскольку он является расширением C и в нем не делается попыток исцелиться от проблем путем выбрасывания различных особенностей. Еще одну интерпретацию названия С++ можно найти в приложении к Оруэллу [8].
 Изначально С++ был разработан, чтобы автору и его друзьям не приходилось программировать на ассемблере, C или других современных языках высокого уровня. Основным его предназначением было сделать написание хороших программ более простым и приятным для отдельного программиста. Плана разработки С++ на бумаге никогда не было. Проект, документация и реализация двигались одновременно. Разумеется, внешний интерфейс С++ был написан на С++. Никогда не существовало «Проекта С++» и «Комитета по разработке С++». Поэтому С++ развивался и продолжает развиваться во всех направлениях, чтобы справляться со сложностями, с которыми сталкиваются пользователи, а также в процессе дискуссий автора с его друзьями и коллегами.
 В качестве базового языка для С++ был выбран C, потому что он
 1. многоцелевой, лаконичный и относительно низкого уровня,
 2. отвечает большинству задач системного программирования,
 3. идет везде и на всем и
 4. пригоден в среде программирования UNIX.
 В C есть свои сложности, но в наспех спроектированном языке тоже были бы свои, а сложности C нам известны. Самое главное, работа с C позволила «C с Классами» быть полезным (правда, неудобным) инструментом в ходе первых месяцев раздумий о добавлении к C Simula-подобных классов.
 С++ стал использоваться шире, и по мере того, как возможности, предоставляемые им помимо возможностей C, становились все более существенными, вновь и вновь поднимался вопрос о том, сохранять ли совместимость с C. Ясно, что отказавшись от определенной части наследия C можно было бы избежать ряда проблем (см., например, Сэти [12]). Это не было сделано, потому что
 1. есть миллионы строк на C, которые могли бы принести пользу в С++ при условии, что их не нужно было бы полностью переписывать с C на С++,
 2. есть сотни тысяч строк библиотечных функций и сервисных программ, написанных на C, которые можно было бы использовать из или на С++ при условии, что С++ полностью совместим с C по загрузке и синтаксически очень похож на C,
 3. есть десятки тысяч программистов, которые знают C, и которым, поэтому, нужно только научиться использовать новые особенности С++, а не заново изучать его основы и
 4. поскольку С++ и C будут использоваться на одних и тех же системах одними и теми же людьми, отличия должны быть либо очень большими, либо очень маленькими, чтобы свести к минимуму ошибки и недоразумения.
 Позднее была проведена проверка определения С++, чтобы удостовериться в том, что любая конструкция, допустимая и в C и в С++, действительно означает в обоих языках одно и то же.
 Язык C сам эволюционировал за последние несколько лет, частично под влиянием развития С++ (см. Ростлер [11]). Предварительный грубый ANSI стандарт C [10] содержит синтаксис описаний функций, заимствованный из «C с Классами». Заимствование идей идет в обе стороны. Например, указатель void* был придуман для ANSI C и впервые реализован в С++. Когда ANSI стандарт разовьется несколько дальше, придет время пересмотреть С++, чтобы удалить необоснованную несовместимость. Будет, например, модернизирован препроцессор (#с.11), и нужно будет, вероятно, отрегулировать правила выполнения плавающей арифметики. Это не должно оказаться болезненным, и C и ANSI C очень близки к тому, чтобы стать подмножествами С++ (см. #с.11).




 Эффективность и Структура


 С++ был развит из языка программирования C и за очень немногими исключениями сохраняет C как подмножество. Базовый язык, C подмножество С++, спроектирован так, что имеется очень близкое соответствие между его типами, операциями и операторами и компьютерными объектами, с которыми непосредственно приходится иметь дело: числами, символами и адресами. За исключением операций свободной памяти new и delete, отдельные выражения и операторы С++ обычно не нуждаются в скрытой поддержке во время выполнения или подпрограммах.
 В С++ используются те же последовательности вызова и возврата из функций, что и в C. В тех случаях, когда даже этот довольно эффективный механизм является слишком дорогим, С++ функция может быть подставлена inline, удовлетворяя, таким образом, соглашению о записи функций без дополнительных расходов времени выполнения.
 Одним из первоначальных предназначений C было применение его вместо программирования на ассемблере в самых насущных задачах системного программирования. Когда проектировался С++, были приняты меры, чтобы не ставить под угрозу успехи в этой области. Различие между C и С++ состоит в первую очередь в степени внимания, уделяемого типам и структурам. C выразителен и снисходителен. С++ еще более выразителен, но чтобы достичь этой выразительности, программист должен уделить больше внимания типам объектов. Когда известны типы объектов, компилятор может правильно обрабатывать выражения, тогда как в противном случае программисту пришлось бы задавать действия с мучительными подробностями. Знание типов объектов также позволяет компилятору обнаруживать ошибки, которые в противном случае остались бы до тестирования. Заметьте, что использование системы типов для того, чтобы получить проверку параметров функций, защитить данные от случайного искажения, задать новые операции и т.д., само по себе не увеличивает расходов по времени выполнения и памяти.
 Особое внимание, уделенное при разработке С++ структуре, отразилось на возрастании масштаба программ, написанных со времени разработки C. Маленькую программу (меньше 1000 строк) вы можете заставить работать с помощью грубой силы, даже нарушая все правила хорошего стиля. Для программ больших размеров это не совсем так. Если программа в 10 000 строк имеет плохую структуру, то вы обнаружите, что новые ошибки появляются так же быстро, как удаляются старые. С++ был разработан так, чтобы дать возможность разумным образом структурировать большие программы таким образом, чтобы для одного человека не было непомерным справляться с программами в 25 000 строк. Существуют программы гораздо больших размеров, однако те, которые работают, в целом, как оказывается, состоят из большого числа почти независимых частей, размер каждой из которых намного ниже указанных пределов. Естественно, сложность написания и поддержки программы зависит от сложности разработки, а не просто от числа строк текста программы, так что точные цифры, с помощью которых были выражены предыдущие соображения, не следует воспринимать слишком серьезно.
 Не каждая часть программы, однако, может быть хорошо структурирована, независима от аппаратного обеспечения, легко читаема и т.п. С++ обладает возможностями, предназначенными для того, чтобы непосредственно и эффективно работать с аппаратными средствами, не заботясь о безопасности или простоте понимания. Он также имеет возможности, позволяющие скрывать такие программы за элегантными и надежными интерфейсами.
 В этой книге особый акцент делается на методах создания универсальных средств, полезных типов, библиотек и т.д. Эти средства пригодятся как тем программистам, которые пишут небольшие программы, так и тем, которые пишут большие. Кроме того, поскольку все нетривиальные программы состоят из большого числа полунезависимых частей, методы написания таких частей пригодятся и системным, и прикладным программистам.
 У кого-то может появиться подозрение, что спецификация программы с помощью более подробной системы типов приведет к увеличению исходных текстов программы. В С++ это не так. С++ программа, описывающая типы параметров функций, использующая классы и т.д., обычно немного короче эквивалентной C программы, в которой эти средства не используются.




 Философские Замечания


 Язык программирования служит двум связанным между собой целям: он дает программисту аппарат для задания действий, которые должны быть выполнены, и формирует концепции, которыми пользуется программист, размышляя о том, что делать. Первой цели идеально отвечает язык, который настолько «близок к машине», что всеми основными машинными аспектами можно легко и просто оперировать достаточно очевидным для программиста образом. С таким умыслом первоначально задумывался C. Второй цели идеально отвечает язык, который настолько «близок к решаемой задаче», чтобы концепции ее решения можно было выражать прямо и коротко. С таким умыслом предварительно задумывались средства, добавленные к C для создания С++.
 Связь между языком, на котором мы думаем/программируем, и задачами и решениями, которые мы можем представлять в своем воображении, очень близка. По этой причине ограничивать свойства языка только целями исключения ошибок программиста в лучшем случае опасно. Как и в случае с естественными языками, есть огромная польза быть по крайней мере двуязычным. Язык предоставляет программисту набор концептуальных инструментов, если они не отвечают задаче, то их просто игнорируют. Например, серьезные ограничения концепции указателя заставляют программиста применять вектора и целую арифметику, чтобы реализовать структуры, указатели и т.п. Хорошее проектирование и отсутствие ошибок не может гарантироваться чисто за счет языковых средств.
 Система типов должна быть особенно полезна в нетривиальных задачах. Действительно, концепция классов в С++ показала себя мощным концептуальным средством.




 Размышления о Программировании на С++


 В идеальном случае подход к разработке программы делится на три части: вначале получить ясное понимание задачи, потом выделить ключевые идеи, входящие в ее решение, и наконец выразить решение в виде программы. Однако подробности задачи и идеи решения часто становятся ясны только в результате попытки выразить их в виде программы – именно в этом случае имеет значение выбор языка программирования.
 В большинстве разработок имеются понятия, которые трудно представить в программе в виде одного из основных типов или как функцию без ассоциированных с ней статических данных. Если имеется подобное понятие, опишите класс, представляющий его в программе. Класс – это тип, это значит, что он задает поведение объектов его класса: как они создаются, как может осуществляться работа с ними, и как они уничтожаются. Класс также задает способ представления объектов. Но на ранних стадиях разработки программы это не является (не должно является) главной заботой. Ключом к написанию хорошей программы является разработка таких классов, чтобы каждый из них представлял одно основное понятие. Обычно это означает, что программист должен сосредоточиться на вопросах: Как создаются объекты этого класса? Могут ли эти объекты копироваться и/или уничтожаться? Какие действия можно производить над этими объектами? Если на такие вопросы нет удовлетворительных ответов, то во-первых, скорее всего, понятие не было «ясно», и может быть неплохо еще немного подумать над задачей и предлагаемым решением, вместо того, чтобы сразу начинать «программировать» сложности.
 Проще всего иметь дело с такими понятиями, которые имеют традиционную математическую форму: числа всех видов, множества, геометрические фигуры и т.п. На самом деле, следовало бы иметь стандартные библиотеки классов, представляющих такие понятия, но к моменту написания это не имело места. С++ еще молод, и его библиотеки не развились еще до той же степени, что и сам язык.
 Понятие не существует в пустоте, всегда есть группы связанных между собой понятий. Организовать в программе взаимоотношения между классами, то есть определить точную взаимосвязь между различными понятиями, часто труднее, чем сначала спланировать отдельные классы. Лучше, чтобы не получилось неразберихи, когда каждый класс (понятие) зависит от всех остальных. Рассмотрим два класса, A и B. Взаимосвязи вроде «A вызывает функции из B», «A создает объекты B» и «A имеет члены B» редко вызывают большие сложности, а взаимосвязь вроде «A использует данные из B» обычно можно исключить (просто не используйте открытые данные-члены). Неприятными, как правило, являются взаимосвязи, которые по своей природе имеют вид «A есть B и ...».
 Одним из наиболее мощных интеллектуальных средств, позволяющих преодолевать сложность, является иерархическое упорядочение, то есть организация связанных между собой понятий в древовидную структуру с самым общим понятием в корне. В С++ такие структуры представляются производными классами. Часто можно организовать программу как множество деревьев (лес?). То есть, программист задает множество базовых классов, каждый из которых имеет свое собственное множество производных классов. Для определения набора действий для самой общей интерпретации понятия (базового класса) часто можно использовать виртуальные функции (#7.2.8). Интерпретацию этих действий можно, в случае необходимости, усовершенствовать для отдельных специальных классов (производных классов).
 Естественно, такая организация имеет свои ограничения. В частности, множество понятий иногда лучше организуется в виде ациклического графа, в котором понятие может непосредственно зависеть от более чем одного другого понятия, например, «A есть B и C и ...». В С++ нет непосредственной поддержки этого, но подобные связи можно представить, немного потеряв в элегантности и проделав малость дополнительной работы (#7.2.5).
 Иногда для организации понятий некоторой программы оказывается непригоден даже ациклический граф, некоторые понятия оказываются взаимозависимыми по своей природе. Если множество взаимозависимых классов настолько мало, что его легко себе представить, то циклические зависимости не должны вызвать сложностей. Для представления множеств взаимозависимых классов с С++ можно использовать идею friend классов (#5.4.1).
 Если вы можете организовать понятия программы только в виде общего графа (не дерева или ациклического направленного графа), и если вы не можете локализовать взаимные зависимости, то вы, по всей видимости, попали в затруднительное положение, из которого вас не выручит ни один язык программирования. Если вы не можете представить какой-либо просто формулируемой зависимости между основными понятиями, то скорее всего справиться с программой не удастся.
 Напомню, что большую часть программирования можно легко и очевидно выполнять, используя только простые типы, структуры данных, обычные функции и небольшое число классов из стандартной библиотеки. Весь аппарат, входящий в определение новых типов, не следует использовать за исключением тех случаев, когда он действительно нужен.
 Вопрос «Как пишут хорошие программы на С++» очень похож на вопрос «Как пишут хорошую английскую прозу?» Есть два вида ответов: «Знайте, что вы хотите сказать» и «Практикуйтесь. Подражайте хорошему языку.» Оба совета оказываются подходящими к С++ в той же мере, сколь и для английского – и им столь же трудно следовать.




 Правила Правой Руки*


 Здесь приводится набор правил, которых вам хорошо бы придерживаться изучая С++. Когда вы станете более опытны, вы можете превратить их в то, что будет подходить для вашего рода деятельности и вашего стиля программирования. Они умышлено сделаны очень простыми, поэтому подробности в них опущены. Не воспринимайте их чересчур буквально. Написание хороших программ требует ума, вкуса и терпения. Вы не собираетесь как следует понять это с самого начала, поэкспериментируйте!
 1. Когда вы программируете, вы создаете конкретное представление идей вашего решения некоторой задачи. Пусть структура отражает эти идеи настолько явно, насколько это возможно:
 a) Если вы считаете «это» отдельным понятием, сделайте его классом.
 b) Если вы считаете «это» отдельным объектом, сделайте его объектом некоторого класса.
 c) Если два класса имеют общим нечто существенное, сделайте его базовым классом. Почти все классы в вашей программе будут иметь нечто общее. Заведите (почти) универсальный базовый класс, и разработайте его наиболее тщательно.
 2. Когда вы определяете класс, который не реализует некоторый математический объект, вроде матрицы или комплексного числа, или тип низкого уровня, вроде связанного списка, то:
 a) Не используйте глобальные данные.
 b) Не используйте глобальные функции (не члены).
 c) Не используйте открытые данные-члены.
 d) Не используйте друзей, кроме как для того, чтобы избежать [a], [b] или [c].
 e) Не обращайтесь к данным-членам или другим объектам непосредственно.
 f) Не помещайте в класс «поле типа», используйте виртуальные функции.
 g) Не используйте inline-функции, кроме как средство существенной оптимизации.




 Замечания для Программистов на C


 Чем лучше кто-нибудь знает C, тем труднее окажется избежать писания на С++ в стиле C, теряя, тем самым, некоторые возможные выгоды С++. Поэтому проглядите, пожалуйста, раздел «Отличия от C» в справочном руководстве (#с.15). Там указываются области, в которых С++ позволяет делать что-то лучше, чем C. Макросы (#define) в С++ почти никогда не бывают необходимы, чтобы определять провозглашаемые константы, используйте const (#2.4.6) или enum (#2.4.7), и inline (#1.12) – чтобы избежать лишних расходов на вызов функции. Старайтесь описывать все функции и типы всех параметров – есть очень мало веских причин этого не делать. Аналогично, практически нет причин описывать локальную переменную не инициализируя ее, поскольку описание может появляться везде, где может стоять оператор, – не описывайте переменную, пока она вам не нужна. Не используйте malloc() – операция new (#3.2.6) делает ту же работу лучше. Многие объединения не нуждаются в имени – используйте безымянные объединения (#2.5.2).




 Библиографические Ссылки


 В тексте мало прямых ссылок на литературу, но здесь приведен короткий список книг и статей, которые прямо или косвенно упоминаются.
 [1] A.V. Aho, J.E. Hopcroft, and J.D. Ulman: Data Structures and Algorithms. Addison-Wesley, Reading, Massachusetts. 1983.
 [2] O-J. Dahl, B. Myrhaug, and K. Nygaard: SIMULA Common Base Language. Norwegian Computer Center S-22, Oslo, Norsay. 1970
 [3] O-J. Dahl and C.A.R. Hoare: Hierarchical Program Construction in «Structured Programming.» Academic Press, New York. 1972. pp 174-220.
 [4] A. Goldberg and D. Robson: SMALLTALK-80 The Language and Its Implementation. Addison-Wesley, Reading, Massachusetts. 1983.
 [5] R.E. Griswold et.al. The Snobol4 Programming Language. Prentice-Hall, Englewood Cliffs, New Jersey. 1970.
 [6] R.E. Griswold and M.T. Griswold: The ICON Programming Language. Prentice-Hall, Englewood Cliffs, New Jersey. 1983.
 [7] Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language. Prentice-Hall, Englewood Cliffs, New Jersey. 1978. Русский перевод в: Б.В. Керниган, Д. Ритчи, А. Фьюэр. Язык программирования Си. М.: Финансы и Статитика. 1985.
 [8] George Orwell: 1984. Secker and Warburg, London. 1949. Русский перевод: Дж. Оруэлл. 1984. ...
 [9] Martin Richards and Colin Whitby-Strevens: BCPL – The Language and Its Compiler. Cambridge University Press. 1980.
 [10] L. Rosler (Chairman, ANSI X3J11 Language Subcommittee): Preliminary Draft Proposed Standard – The C Language. X3 Secretariat: Computer and Busineess Equipment Manufacturers Association, 311 First Street, N.W, Suite 500, Washington, DC 20001, USA.
 [11] L.Rosler: The Evolution of C – Past and Future. AT amp;T Bell Laboratories Technical Journal. Vol.63 No.8 Part 2. October 1984. pp 1685-1700.
 [12] Ravi Sethi: Uniform Syntax for Type Expressions and Declarations. Software Practice amp; Experience, Vol 11 (1981), pp 623-628.
 [13] Bjarne Stroustrup: Adding Classes to C: An Exercise in Language Evolution. Software Practice amp; Experience, 13 (1981), pp 139-61.
 [14] P.M. Woodward and S.G. Bond: Algol 68-R Users Guide. Her Majesty's Stationery Office, London. 1974.
 [15] UNIX System V Release 2.0 User Reference Manual. AT amp;T Bell Laboratories, Murray Hill, New Jersey. December 1983.
 [16] UNIX Time-Sharing System: Programmer's Manual. Research Version, Eighth Edition. AT amp;T Bell Laboratories, Murray Hill, New Jersey. February 1985.
 [17] UNIX Programmer's Manual. 4.2 Berkeley Software Distribution University of California, Berkeley, California. March 1984.




 Глава 1 Турне по С++



 Единственный способ изучать новый язык программирования – писать на нем программы.

    Брайэн Керниган

 Эта глава представляет собой краткий обзор основных черт языка программирования С++. Сначала приводится программа на С ++, затем показано, как ее откомпилировать и запустить, и как такая программа может выводить выходные данные и считывать входные. В первой трети этой главы после введения описаны наиболее обычные черты С++: основные типы, описания, выражения, операторы, функции и структура программы. Оставшаяся часть главы посвящена возможностям С++ по определению новых типов, сокрытию данных, операциям, определяемым пользователем, и иерархии определяемых пользователем типов.




 1.1 Введение


 Это турне проведет вас через ряд программ и частей программ на С++. К концу у вас должно сложиться общее представление об основных особенностях С++, и будет достаточно информации, чтобы писать простые программы. Для точного и полного объяснения понятий, затронутых даже в самом маленьком законченном примере, потребовалось бы несколько страниц определений. Чтобы не превращать эту главу в описание или в осуждение общих понятий, примеры снабжены только самыми короткими определениями используемых терминов. Термины рассматриваются позже, когда будет больше примеров, способствующих обсуждению.




 1.1.1 Вывод


 Прежде всего, давайте напишем программу, выводящую строку выдачи:
 #include «stream.h»
 main() (* cout «„ «Hello, world\n“; *)
 Строка #include «stream.h» сообщает компилятору, чтобы он включил стандартные возможности потока ввода и вывода, находящиеся в файле stream.h. Без этих описаний выражение cout «„ „Hello, world\n“ не имело бы смысла. Операция „« («пометить в“*) пишет свой первый аргумент во второй (в данном случае, строку «Hello, world\n“ в стандартный поток вывода cout). Строка – это последовательность символов, заключенная в двойные кавычки. В строке символ обратной косой \, за которым следует другой символ, обозначает один специальный символ, в данном случае, \n является символом новой строки. Таким образом выводимые символы состоят из Hello, world и перевода строки.
 – * Программирующим на C «« известно как операция сдвига влево для целых. Такое использование «« не утеряно, просто в дальнейшем «« было определено для случая, когда его левый операнд является потоком вывода. Как это делается, описано в #1.8. (прим. автора)
 Остальная часть программы
 main() (* ... *)
 определяет функцию, названную main. Каждая программа должна содержать функцию с именем main, и работа программы начинается с выполнения этой функции.




 1.1.2 Компиляция


 Откуда появились выходной поток cout и код, реализующий операцию вывода ««? Для получения выполняемого кода написанная на С++ программа должна быть скомпилирована. По своей сути процесс компиляции такой же, как и для С, и в нем участвует большая часть входящих в последний программ. Производится чтение и анализ текста программы, и если не обнаружены ошибки, то генерируется код. Затем программа проверяется на наличие имен и операций, которые использовались, но не были определены (в нашем случае это cout и ««). Если это возможно, то программа делается полной посредством дополнения недостающих определений из библиотеки (есть стандартные библиотеки, и пользователи могут создавать свои собственные). В нашем случае cout и «« были описаны в stream.h, то есть, были указаны их типы, но не было дано никаких подробностей относительно их реализации. В стандартной библиотеке содержится спецификация пространства и инициализирующий код для cout и ««. На самом деле, в этой библиотеке содержится и много других вещей, часть из которых описана в stream.h, однако к скомпилированной версии добавляется только подмножество библиотеки, необходимое для того, чтобы сделать нашу программу полной.
 Команда компиляции в С++ обычно называется CC. Она используется так же, как команда cc для программ на C, подробности вы можете найти в вашем руководстве. Предположим, что программа с «Hello, world» хранится в файле с именем hello.c, тогда вы можете ее скомпилировать и запустить примерно так ($ – системное приглашение):
 $ CC hello.c $ a.out Hello,world $
 a.out – это принимаемое по умолчанию имя исполняемого результата компиляции. Если вы хотите назвать свою программу, вы можете сделать это с помощью опции -o:
 $ CC hello.c -o hello $ hello Hello,world $




 1.1.3 Ввод


 Следующая (довольно многословная) программа предлагает вам ввести число дюймов. После того, как вы это сделаете, она напечатает соответствующее число сантиметров.
 #include «stream.h»
 main() (* int inch = 0; // inch – дюйм cout «„ „inches“; cin “» inch; cout «„ inch; cout «« " in = "; cout «« inch*2.54; cout «« « cm\n“; *)
 Первая строка функции main() описывает целую переменную inch. Ее значение считывается с помощью операции »» («взять из») над стандартным потоком ввода cin. Описания cin и »», конечно же, находятся в «stream.h». После ее запуска ваш терминал может выглядеть примерно так:
 $ a.out inches=12 12 in = 30.48 cm $
 В этом примере на каждую команду вывода приходится один оператор. Это слишком длинно. Операцию вывода «« можно применять к ее собственному результату, так что последние четыре команды вывода можно было записать одним оператором:
 cout «„ inch «« " in = " «« inch*2.54 «« « cm\n“;
 В последующих разделах ввод и вывод будут описаны гораздо более подробно. Вся эта глава фактически может рассматриваться как объяснение того, как можно написать предыдущие программы на языке, который не обеспечивает операции ввода-вывода. На самом деле, приведенные выше программы написаны на С++, «расширенном» операциями ввода-вывода посредством использования библиотек и включения файлов с помощью #include. Другими словами, язык С++ в том виде, в котором он описан в справочном руководстве, не определяет средств ввода-вывода. Вместо этого исключительно с помощью средств, доступных любому программисту, определены операции «„ и “».




 1.2 Комментарии


 Часто бывает полезно вставлять в программу текст, который предназначается в качестве комментария только для читающего программу человека и игнорируется компилятором в программе. В С++ это можно сделать одним из двух способов.
 Символы /* начинают комментарий, заканчивающийся символами */. Вся эта последовательность символов эквивалентна символу пропуска (например, символу пробела). Это наиболее полезно для многострочных комментариев и изъятия частей программы при редактировании, однако следует помнить, что комментарии /* */ не могут быть вложенными.
 Символы // начинают комментарий, который заканчивается в конце строки, на которой они появились. Опять, вся последовательность символов эквивалентна пропуску. Этот способ наиболее полезен для коротких комментариев. Символы // можно использовать для того, чтобы закомментировать символы /* или */, а символами /* можно закомментировать //.




 1.3 Типы и Описания


 Каждое имя и каждое выражение имеет тип, определяющий операции, которые могут над ними производиться. Например, описание
 int inch;
 определяет, что inch имеет тип int, то есть, inch является целой переменной.
 Описание – это оператор, который вводит имя в программе. Описание задает тип этого имени. Тип определяет правильное использование имени или выражения. Для целых определены такие операции, как +, -, * и /. После того, как включен файл
 stream.h, объект типа int может также быть вторым операндом ««, когда первый операнд ostream. Тип объекта определяет не только то, какие операции могут к нему применяться, но и смысл этих операций. Например, оператор
 cout «„ inch «« " in = " «« inch*2.54 «« « cm\n“;
 правильно обрабатывает четыре входных значения различным образом. Строки печатаются буквально, тогда как целое inch и значение с плавающей точкой inch*2.54 преобразуются из их внутреннего представления в подходящее для человеческого глаза символьное представление.
 В С++ есть несколько основных типов и несколько способов создавать новые. Простейшие виды типов С++ описываются в следующих разделах, а более интересные оставлены на потом.




 1.3.1 Основные Типы


 Основные типы, наиболее непосредственно отвечающие средствам аппаратного обеспечения, такие:
 char short int long float double
 Первые четыре типа используются для представления целых, последние два – для представления чисел с плавающей точкой. Переменная типа char имеет размер, естественный для хранения символа на данной машине (обычно, байт), а переменная типа int имеет размер, соответствующий целой арифметике на данной машине (обычно, слово). Диапазон целых чисел, которые могут быть представлены типом, зависит от его размера (sizeof). В С ++ размеры измеряются в единицах размера данных типа char, поэтому char по определению имеет размер единица. Соотношение между основными типами можно записать так:
 1=sizeof(char)«=sizeof(short) «= sizeof(int) «= sizeof(long) sizeof(float) «= sizeof(double)
 В целом, предполагать что-либо еще относительно основных типов неразумно. В частности, то, что целое достаточно для хранения указателя, верно не для всех машин.
 К основному типу можно применять прилагательное const. Это дает тип, имеющий те же свойства, что и исходный тип, за исключением того, что значение переменных типа const не может изменяться после инициализации.
 const float pi = 3.14; const char plus = '+';
 Символ, заключенный в одинарные кавычки, является символьной константой. Заметьте, что часто константа, определенная таким образом, не занимает память. Просто там, где требуется, ее значение может использоваться непосредственно. Константа должна инициализироваться при описании. Для переменных инициализация необязательна, но настоятельно рекомендуется. Оснований для введения локальной переменной без ее инициализации очень немного.
 К любой комбинации этих типов могут применяться арифметические операции:
 + (плюс, унарный и бинарный) – (минус, унарный и бинарный) * (умножение) / (деление)
 А также операции сравнения: == (равно) != (не равно) « (меньше) » (больше) «= (меньше или равно) »= (больше или равно)
 Заметьте, что целое деление дает целый результат: 7/2 есть 3. Над целыми может выполняться операция % получения остатка: 7%2 равно 1.
 При присваивании и арифметических операциях С++ выполнит все осмысленные преобразования между основными типами, чтобы их можно было сочетать без ограничений:
 double d = 1; int i = 1; d = d + i; i = d + i;




 1.3.2 Производные Типы


 Вот операции, создающие из основных типов новые типы:
 * указатель на *const константный указатель на amp; ссылка на [] вектор* () функция, возвращающая
 – * одномерный массив. Это принятый термин (например, вектора прерываний), и мы сочли, что стандартный перевод его как «массив» затуманит изложение. (прим. перев.)
 Например:
 char* p // указатель на символ char *const q // константный указатель на символ char v[10] // вектор из 10 символов
 Все вектора в качестве нижней границы индекса имеют ноль, поэтому в v десять элементов: v[0]..v[9]. Функции объясняются в #1.5, ссылки в #1.9. Переменная указатель может содержать адрес объекта соответствующего типа:
 char c; // ... p = amp;c; // p указывает на c
 Унарное amp; является операцией взятия адреса.




 1.4 Выражения и Операторы


 В С++ имеется богатый набор операций, с помощью которых в выражениях образуются новые значения и изменяются значения переменных. Поток управления в программе задается с помощью операторов, а описания используются для введения в программе имен переменных, констант и т.д. Заметьте, что описания являются операторами, поэтому они свободно могут сочетаться с другими операторами.
  1.4.1 Выражения 
 В С++ имеется большое число операций, и они будут объясняться там, где (и если) это потребуется. Следует учесть, что операции
 ~ (дополнение) amp; (И) ^ (исключающее ИЛИ) ! (включающее ИЛИ) «„ (логический сдвиг влево) “» (логический сдвиг вправо)
 применяются к целым, и что нет отдельного типа данных для логических действий.
 Смысл операции зависит от числа операндов. Унарное amp; является операцией взятия адреса, а бинарное amp; – это операция логического И. Смысл операции зависит также от типа ее операндов: + в выражении a+b означает сложение с плавающей токой, если операнды имеют тип float, но целое сложение, если они типа int. В #1.8 объясняется, как можно определить операцию для типа, определяемого пользователем, без потери ее значения, предопределенного для основных и производных типов.
 В С++ есть операция присваивания =, а не оператор присваивания, как в некоторых языках. Таким образом, присваивание может встречаться в неожиданном контексте, например, x=sqrt(a =3*x). Это бывает полезно. a=b=c означает присвоение c объекту b, а затем объекту a. Другим свойством операции присваивания является то, что она может совмещаться с большинством бинарных операций. Например, x[i+3]*=4 означает x[i+3]=x[i+3]*4, за исключением того факта, что выражение x[i +3] вычисляется только один раз. Это дает привлекательную степень эффективности без необходимости обращения к оптимизирующим компиляторам. К тому же это более кратко.
 В большинстве программ на С++ широко применяются указатели. Унарная операция * разыменовывает* указатель, т.е. *p есть объект, на который указывает p. Эта операция также называется косвенной адресацией. Например, если имеется char* p, то *p есть символ, на который указывает p. Часто при работе с указателями бывают полезны операция увеличения ++ и операция уменьшения –. Предположим, p указывает на элемент вектора v, тогда p++ делает p указывающим на следующий элемент.
 – * англ. dereference – получить значение объекта, на который указывает данный указатель. (прим. перев.)




 1.4.2 Операторы Выражения


 Самый обычный вид оператора – выражение;. Он состоит из выражения, за которым следует точка с запятой. Например:
 a = b*3+c; cout «„ «go go go“; lseek(fd,0,2);
 1.4.3 Пустой оператор
 Простейшей формой оператора является оператор:
 ;
 Он не делает ничего. Однако он может быть полезен в тех случаях, когда синтаксис требует наличие оператора, а вам
 оператор не нужен. 1.4.4 Блоки Блок – это возможно пустой список операторов, заключенный в фигурные скобки:
 (* a=b+2; b++; *)
 Блок позволяет рассматривать несколько операторов как один. Область видимости имени, описанного в блоке, простирается до конца блока. Имя можно сделать невидимым с помощью описаний такого же имени во внутренних блоках.




 1.4.5 Оператор if


 Программа в следующем примере осуществляет преобразование дюймов в сантиметры и сантиметров в дюймы. Предполагаемся, что вы укажете единицы измерения вводимых данных, добавляя i для дюймов и c для сантиметров:
 #include «stream.h»
 main() (* const float fac = 2.54; float x, in, cm; char ch = 0;
 cout «„ "введите длину: "; cin “» x »» ch;
 if (ch == 'i') (* // inch – дюймы in = x; cm = x*fac; *) else if (ch == 'c') // cm – сантиметры in = x/fac; cm = x; *) else in = cm = 0;
 cout «„ in «« " in = " «« cm «« « cm\n“; *)
 Заметьте, что условие в операторе if должно быть заключено в круглые скобки.




 1.4.6 Операторы switch


 Оператор switch производит сопоставление значения с множеством констант. Проверки в предыдущем примере можно записать так:
 switch (ch) (* case 'i': in = x; cm = x*fac; break; case 'c': in = x/fac; cm = x; break; default: in = cm = 0; break; *) Операторы break применяются для выхода из оператора
 switch. Константы в вариантах case должны быть различными, и если проверяемое значение не совпадает ни с одной из констант, выбирается вариант default. Программисту не обязательно предусматривать default.




 1.4.7 Оператор while


 Рассмотрим копирование строки, когда заданы указатель p на ее первый символ и указатель q на целевую строку. По соглашению строка оканчивается символом с целым значением 0.
 while (p != 0) (* *q = *p; // скопировать символ q = q+1; p = p+1; *) *q = 0; // завершающий символ 0 скопирован не был
 Следующее после while условие должно быть заключено в круглые скобки. Условие вычисляется, и если его значение не ноль, выполняется непосредственно следующий за ним оператор. Это повторяется до тех пор, пока вычисление условия не даст ноль.
 Этот пример слишком пространен. Можно использовать операцию ++ для непосредственного указания увеличения, и проверка упростится:
 while (*p) *q++ = *p++; *q = 0;
 где конструкция *p++ означает: «взять символ, на который указывает p, затем увеличить p.»
 Пример можно еще упростить, так как указатель p разыменовывается дважды за каждый цикл. Копирование символа можно делать тогда же, когда производится проверка условия:
 while (*q++ = *p++) ;
 Здесь берется символ, на который указывает p, p увеличивается, этот символ копируется туда, куда указывает q, и q увеличивается. Если символ ненулевой, цикл повторяется. Поскольку вся работа выполняется в условии, не требуется ни оного оператора. Чтобы указать на это, используется пустой оператор. С++ (как и C) одновременно любят и ненавидят за возможность такого чрезвычайно краткого ориентированного на выразительность программирования*.
 – * в оригинале expression-oriented (expression – выразительность и выражение). (прим. перев.)




 1.4.8 Оператор for


 Рассмотрим копирование десяти элементов одного вектора в другой:
 for (int i=0; i«10; i++) q[i]=p[i];
 Это эквивалентно int i = 0; while (i«10) (* q[i] = p[i]; i++; *) но более удобочитаемо, поскольку вся информация, управляющая циклом, локализована. При применении операции ++ к целой переменной к ней просто добавляется единица. Первая часть оператора for не обязательно должна быть описанием, она может быть любым оператором. Например:
 for (i=0; i«10; i++) q[i]=p[i];
 тоже эквивалентно предыдущей записи при условии, что i соответствующим образом описано раньше.




 1.4.9 Описания


 Описание – это оператор, вводящий имя в программе. Оно может также инициализировать объект с этим именем. Выполнение описания означает, что когда поток управления доходит до описания, вычисляется инициализирующее выражение (инициализатор) и производится инициализация. Например:
 for (int i = 1; i«MAX; i++) (* int t = v[i-1]; v[i-1] = v[i]; v[i] = t; *)
 При каждом выполнении оператора for i будет инициализироваться один раз, а t MAX-1 раз.




 1.5 Функции


 Функция – это именованная часть программы, к которой можно обращаться из других частей программы столько раз, сколько потребуется. Рассмотрим программу, печатающую степени числа 2:
 extern float pow(float, int); //pow() определена в другом месте
 main() (* for (int i=0; i«10; i++) cout „« pow(2,i) «« «\n“; *)
 Первая строка функции – ее описание, указывающее, что pow – функция, получающая параметры типа float и int и возвращающая float. Описание функции используется для того, чтобы сделать определенными обращения к функции в других местах.
 При вызове функции тип каждого параметра сопоставляется с ожидаемым типом точно так же, как если бы инициализировалась переменная описанного типа. Это гарантирует надлежащую проверку и преобразование типов. Например, обращение pow(12.3,"abcd") вызовет недовольство компилятора, поскольку «abcd» является строкой, а не int. При вызове pow(2,i) компилятор преобразует 2 к типу float, как того требует функция. Функция pow может быть определена например так:
 float pow(float x, int n) (* if (n « 0) error(„sorry, negative exponent to pow()“); // извините, отрицательный показатель для pow() switch (n) (* case 0: return 1; case 1: return x; default: return x*pow(x,n-1); *) *) Первая часть определения функции задает имя функции, тип возвращаемого ею значения (если таковое имеется) и типы и имена ее параметров (если они есть). Значение возвращается из функции с помощью оператора return.
 Разные функции, обычно имеют разные имена, но функциям, выполняющим сходные действия над объектами различных типов, иногда лучше дать возможность иметь одинаковые имена. Если типы их параметров различны, то компилятор всегда может различить их и выбрать для вызова нужную функцию. Может, например, иметься одна функция возведения в степень для целых переменных и другая для переменных с плавающей точкой:
 overload pow; int pow(int, int); double pow(double, double); //... x=pow(2,10); y=pow(2.0,10.0);
 Описание overload pow;
 сообщает компилятору, что использование имени pow более чем для одной функции является умышленным.
 Если функция не возвращает значения, то ее следует описать как void:
 void swap(int* p, int* q) // поменять местами (* int t = *p; *p = *q; *q = t; *)




 1.6 Структура программы


 Программа на С++ обычно состоит из большого числа исходных файлов, каждый из которых содержит описания типов, функций, переменных и констант. Чтобы имя можно было использовать в разных исходных файлах для ссылки на один и тот же объект, оно должно быть описано как внешнее. Например:
 extern double sqrt(double); extern instream cin;
 Самый обычный способ обеспечить согласованность исходных файлов – это поместить такие описания в отдельные файлы, называемые заголовочными (или хедер) файлами, а затем включить, то есть скопировать, эти заголовочные файлы во все файлы, где нужны эти описания. Например, если описание sqrt хранится в заголовочном файле для стандартных математических функций math.h, и вы хотите извлечь квадратный корень из 4, можно написать:
 #include «math.h» //... x = sqrt(4);
 Поскольку обычные заголовочные файлы включаются во многие исходные файлы, они не содержат описаний, которые не должны повторяться. Например, тела функций даются только для inline-подставляемых функций (#1.12) и инициализаторы даются только для констант (#1.3.1). За исключением этих случаев, заголовочный файл является хранилищем информации о типах. Он обеспечивает интерфейс между отдельно компилируемыми частями программы.
 В команде включения include имя файла, заключенное в угловые скобки, например «math.h», относится к файлу с этим именем в стандартном каталоге (часто это /usr/include/CC), на файлы, находящиеся в каких-либо других местах ссылаются с помощью имен, заключенных в двойные кавычки. Например:
 #include «math1.h» #include «/usr/bs/math2.h»
 включит math1.h из текущего пользовательского каталога, а math2.h из каталога /usr/bs.
 Здесь приводится очень маленький законченный пример программы, в котором строка определяется в одном файле, а ее печать производится в другом. Файл header.h определяет необходимые типы:
 // header.h
 extern char* prog_name; extern void f();
 В файле main.c находится главная программа:
 // main.c
 #include «header.h» char* prog_name = «дурацкий, но полный»; main() (* f(); *)
 а файл f.c печатает строку:
 // f.c
 #include «stream.h» #include «header.h» void f() (* cout «„ prog_name «« «\n“; *)
 Скомпилировать и запустить программу вы можете например так:
 $ CC main.c f.c -o silly $ silly дурацкий, но полный $




 1.7 Классы


 Давайте посмотрим, как мы могли бы определить тип потока вывода ostream. Чтобы упростить задачу, предположим, что для буферизации определен тип streambuf. Тип streambuf на самом деле определен в «stream.h», где также находится и настоящее определение ostream.
 Пожалуйста, не испытывайте примеры, определяющие ostream в этом и последующих разделах. Пока вы не сможете полностью избежать использования «stream.h», компилятор будет возражать против переопределений.
 Определение типа, определяемого пользователем (который в С++ называется class, т.е. класс), специфицирует данные, необходимые для представления объекта этого типа, и множество операций для работы с этими объектами. Определение имеет две части: закрытую (private) часть, содержащую информацию, которой может пользоваться только его разработчик, и открытую (public) часть, представляющую интерфейс типа с пользователем:
 class ostream (* streambuf* buf; int state; public: void put(char*); void put(long); void put(double); *)
 Описания после метки public: задают интерфейс: пользователь может обращаться только к трем функциям put(). Описания перед меткой public задают представление объекта класса ostream. Имена buf и state могут использоваться только функциями put(), описанными в открытой части.
 class определяет тип, а не объект данных, поэтому чтобы использовать ostream, мы должны один такой объект описать (так же, как мы описываем переменные типа int):
 ostream my_out;
 Считая, что my_out был соответствующим образом проинициализирован (как, объясняется в #1.10), его можно использовать например так:
 my_out.put(«Hello, world\n»);
 С помощью операции точка выбирается член класса для данного объекта этого класса. Здесь для объекта my_out вызывается член функция put().
 Функция может определяться так:
 void ostream::put(char* p) (* while (*p) buf.sputc(*p++); *)
 где sputc() – функция, которая помещает символ в streambuf. Префикс ostream необходим, чтобы отличить put() ostream'а от других функций с именем put().
 Для обращения к функции члену должен быть указан объект класса. В функции члене можно ссылаться на этот объект неявно, как это делалось выше в ostream::put(): в каждом вызове buf относится к члену buf объекта, для которого функция вызвана. Можно также ссылаться на этот объект явно посредством указателя с именем this. В функции члене класса X this неявно описан как X* (указатель на X) и инициализирован указателем на тот объект, для которого эта функция вызвана. Определение ostream::put() можно также записать в виде:
 void ostream::put(char* p) (* while (*p) this-»buf.sputc(*p++); *) Операция -» применяется для выбора члена объекта, заданного указателем.




 1.8 Перегрузка операций


 Настоящий класс ostream определяет операцию ««, чтобы сделать удобным вывод нескольких объектов одним оператором. Давайте посмотрим, как это сделано.
 Чтобы определить @, где @ – некоторая операция языка С++, для каждого определяемого пользователем типа вы определяете функцию с именем operator@, которая получает параметры соответствующего типа. Например:
 class ostream (* //... ostream operator««(char*); *);
 ostream ostream::operator««(char* p) (* while (*p) buf.sputc(*p++); return *this; *)
 определяет операцию «« как член класса ostream, поэтому s««p интерпретируется как s.operator««(p), когда s является ostream и p – указатель на символ. Операция «« бинарна, а функция operator««(char*) на первый взгляд имеет только один параметр. Однако, помимо этого она имеет свой стандартный параметр this.
 То, что в качестве возвращаемого значения возвращается ostream, позволяет применять «« к результату операции вывода. Например, s««p««q интерпретируется как (s.operator««(p)).operator««(q). Так задаются операции вывода для встроенных типов.
 С помощью множества операций, заданных как открытые члены класса ostream, вы можете теперь определить «« для такого определяемого типа, как complex, не изменяя описание класса ostream:
 ostream operator««(ostream s, complex z) // у complex две части: действительная real и мнимая imag // печатает complex как (real,imag) (* return s «« "(" «« z.real «« "," «« z.imag «« ")'; *)
 Поскольку operator««(ostream,complex) не является функцией членом, для бинарности необходимо два явных параметра. Вывод значений будет производиться в правильном порядке, потому что ««, как и большинство операций С++, группирует слева направо, то есть f««b««c означает (a««b)««c. При интерпретации операций компилятору известна разница между функциями членами и функциями не членами. Например, если z – комплексная переменная, то s««z будет расширяться с помощью вызова стандартной функции (не члена) operator««(s,z).




 1.9 Ссылки


 К сожалению, последняя версия ostream содержит серьезную ошибку и к тому же очень неэффективна. Сложность состоит в том, что ostream копируется дважды при каждом использовании ««: один раз как параметр и один раз как возвращаемое значение. Это оставляет state неизмененным после каждого вызова. Необходима возможность передачи указателя на ostream вместо передачи самого ostream.
 Это можно сделать с помощью ссылок. Ссылка действует как имя для объекта. T amp; означает ссылку на T. Ссылка должна быть инициализирована, и она становится другим именем того объекта, которым она инициализирована. Например:
 ostream amp; s1 = my_out; ostream amp; s2 = cout;
 Теперь можно использовать ссылку s1 и my_out одинаково, и они будут иметь одинаковые значения. Например, присваивание
 s1 = s2;
 копирует объект, на который ссылается s2 (то есть, cout), в объект, на который ссылается s1 (то есть, my_out). Члены берутся с помощью операции точка
 s1.put(«не надо использовать -»»);
 а если применить операцию взятия адреса, то вы получите адрес объекта, на который ссылается ссылка:
 amp;s1 == amp;my_out
 Первая очевидная польза от ссылок состоит в том, чтобы обеспечить передачу адреса объекта, а не самого объекта, в функцию вывода (в некоторых языках это называется вызов по ссылке):
 ostream amp; operator««(ostream amp; s, complex z) (* return s «« "(" «« z.real «« "," «« z.imag «« ")"; *)
 Достаточно интересно, что тело функции осталось без изменений, но если вы будете осуществлять присваивание s, то будете воздействовать на сам объект, а не на его копию. В данном случае то, что возвращается ссылка, также повышает эффективность, поскольку очевидный способ реализации ссылки – это указатель, а передача указателя гораздо дешевле, чем передача большой структуры данных.
 Ссылки также существенны для определения потока ввода, поскольку операция ввода получает в качестве операнда переменную для считывания. Если бы ссылки не использовались, то пользователь должен был бы явно передавать указатели в функции ввода.
 class istream (* //... int state; public: istream amp; operator»»(char amp;); istream amp; operator»»(char*); istream amp; operator»»(int amp;); istream amp; operator»»(long amp;); //... *);
 Заметьте, что для чтения long и int используются разные функции, тогда как для их печати требовалась только одна. Это вполне обычно, и причина в том, что int может быть преобразовано в long по стандартным правилам неявного преобразования (#с.6.6), избавляя таким образом программиста от беспокойства по поводу написания обеих функций ввода.




 1.10 Конструкторы


 Определение ostream как класса сделало члены данные зарытыми. Только функция член имеет доступ к закрытым членам, поэтому надо предусмотреть функцию для инициализации. Такая функция называется конструктором и отличается тем, что имеет то же имя, что и ее класс:
 class ostream (* //... ostream(streambuf*); ostream(int size, char* s); *);
 Здесь задано два конструктора. Один получает вышеупомянутый streambuf для реального вывода, другой получает размер и указатель на символ для форматирования строки. В описании необходимый для конструктора список параметров присоединяется к имени. Теперь вы можете, например, описать такие потоки:
 ostream my_out( amp;some_stream_buffer); char xx[256]; ostream xx_stream(256,xx);
 Описание my_out не только задает соответствующий объем памяти где-то в другом месте, оно также вызывает конструктор ostream::ostream(streambuf*), чтобы инициализировать его параметром amp;some_stream_buffer, предположительно указателем на подходящий объект класса streambuf. Описание конструкторов для класса не только дает способ инициализации объектов, но также обеспечивает то, что все объекты этого класса будут проинициализированы. Если для класса были описаны конструкторы, то невозможно описать переменную этого класса так, чтобы конструктор не был вызван. Если класс имеет конструктор, не получающий параметров, то этот конструктор будет вызываться в том случае, если в описании нет ни одного параметра.




 1.11 Вектора


 Встроенное в С++ понятие вектора было разработано так, чтобы обеспечить максимальную эффективность выполнения при минимальном расходе памяти. Оно также (особенно когда используется совместно с указателями) является весьма универсальным инструментом для построения средств более высокого уровня. Вы могли бы, конечно, возразить, что размер вектора должен задаваться как константа, что нет проверки выхода за границы вектора и т.д. Ответ на подобные возражения таков: «Вы можете запрограммировать это сами.» Давайте посмотрим, действительно ли оправдан такой ответ. Другими словами, проверим средства абстракции языка С++, попытавшись реализовать эти возможности для векторных типов, которые мы создадим сами, и посмотрим, какие с этим связаны трудности, каких это требует затрат, и насколько получившиеся векторные типы удобны в обращении. class vector (* int* v; int sz; public: vector(int); // конструктор ~vector(); // деструктор int size() (* return sz; *) void set_size(int); int amp; operator[](int); int amp; elem(int i) (* return v[i]; *) *); Функция size возвращает число элементов вектора, таким образом индексы должны лежать в диапазоне 0 ... size()-1. Функция set_size сделана для изменения этого размера, elem обеспечивает доступ к элементам без проверки индекса, а operator[] дает доступ с проверкой границ.
 Идея состоит в том, чтобы класс сам был структурой фиксированного размера, управляющей доступом к фактической памяти вектора, которая выделяется конструктором вектора с помощью распределителя свободной памяти new:
 vector::vector(int s) (* if (s«=0) error(„bad vector size“); // плохой размер вектора sz = s; v = new int[s]; *)
 Теперь вы можете описывать вектора типа vector почти столь же элегантно, как и вектора, встроенные в сам язык:
 vector v1(100); vector v2(nelem*2-4);
 Операцию доступа можно определить как
 int amp; vector::operator[](int i) (* if(i«0 !! sz„=i) error(«vector index out of range“); // индекс выходит за границы вектора return v[i]; *)
 Операция !! (ИЛИИЛИ) – это логическая операция ИЛИ. Ее правый операнд вычисляется только тогда, когда это необходимо, то есть если вычисление левого операнда дало ноль. Возращение ссылки обеспечивает то, что запись [] может использоваться с любой стороны операции присваивания:
 v1[x] = v2[y];
 Функция со странным именем ~vector – это деструктор, то есть функция, описанная для того, чтобы она неявно вызывалась, когда объект класса выходит из области видимости. Деструктор класса C имеет имя ~C. Если его определить как
 vector::~vector() (* delete v; *)
 то он будет, с помощью операции delete, освобождать пространство, выделенное конструктором, поэтому когда vector выходит из области видимости, все его пространство возвращается обратно в память для дальнейшего использования.
   1.12 Inline-подстановка  
 Если часто повторяется обращение к очень маленькой функции, то вы можете начать беспокоиться о стоимости вызова функции. Обращение к функции члену не дороже обращения к функции не члену с тем же числом параметров (надо помнить, что функция член всегда имеет хотя бы один параметр), и вызовы в функций в С++ примерно столь же эффективны, сколь и в любом языке. Однако для слишком маленьких функций может встать вопрос о накладных расходах на обращение. В этом случае можно рассмотреть возможность спецификации функции как inline-подставляемой. Если вы поступите таким образом, то компилятор сгенерирует для функции соответствующий код в мете ее вызова. Семантика вызова не изменяется. Если, например, size и elem inline-подставляемые, то
 vector s(100); //... i = s.size(); x = elem(i-1);
 порождает код, эквивалентный
 //... i = 100; x = s.v[i-1];
 С++ компилятор обычно достаточно разумен, чтобы генерировать настолько хороший код, насколько вы можете получить в результате прямого макрорасширения. Разумеется, компилятор иногда вынужден использовать временные переменные и другие уловки, чтобы сохранить семантику.
 Вы можете указать, что вы хотите, чтобы функция была inline-подставляемой, поставив ключевое слово inline, или, для функции члена, просто включив определение функции в описание класса, как это сделано в предыдущем примере для size() и elem().
 При хорошем использовании inline-функции резко повышают скорость выполнения и уменьшают размер объектного кода. Однако, inline функции запутывают описания и могут замедлить компиляцию, поэтому, если они не необходимы, то их желательно избегать. Чтобы inline функция давала существенный выигрыш по сравнению с обычной функцией, она должна быть очень маленькой.




 1.13 Производные классы


 Теперь давайте определим вектор, для которого пользователь может задавать границы изменения индекса.
 class vec: public vector (* int low, high; public: vec(int,int);
 int amp; elem(int); int amp; operator[](int); *);
 Определение vec как :public vector
 означает, в первую очередь, что vec – это vector. То есть, тип vec имеет (наследует) все свойства типа vector дополнительно к тем, что описаны специально для него. Говорят, что vector является базовым классом для vec, а о vec говорится, что он производный класс от vector. Класс vec модифицирует класс vector тем, что в нем задается другой конструктор, который требует от пользователя указывать две границы изменения индекса, а не длину, и имеются свои собственные функции доступа elem(int) и operator[](int). Функция elem() класса vec легко выражается через elem() класса vector: int amp; vec::elem(int i) (* return vector::elem(i-low); *)
 Операция разрешения области видимости :: используется для того, чтобы не было бесконечной рекурсии обращения к vec::elem() из нее самой. с помощью унарной операции :: можно ссылаться на нелокальные имена. Было бы разумно описать vec:: elem() как inline, поскольку, скорее всего, эффективность существенна, но необязательно, неразумно и невозможно написать ее так, чтобы она непосредственно использовала закрытый член v класса vector. Функции производного класса не имеют специального доступа к закрытым членам его базового класса.
 Конструктор можно написать так:
 vec::vec(int lb, int hb) : (hb-lb+1) (* if (hb-lb«0) hb = lb; low = lb; high = hb; *)
 Запись: (hb-lb+1) используется для определения списка параметров конструктора базового класса vector::vector(). Этот конструктор вызывается перед телом vec::vec(). Вот небольшой пример, который можно запустить, если скомпилировать его вместе с остальными описаниями vector:
 #include «streams.h»
 void error(char* p) (* cerr «„ p «« «\n“; // cerr – выходной поток сообщений об ошибках exit(1); *)
 void vector::set_size(int) (* /* пустышка */ *)
 int amp; vec::operator[](int i) (* if (i«low !! high„i) error(«vec index out of range“); // индекс vec за границами return elem(i); *)
 main() (* vector a(10); for (int i=0; i«a.size(); i++) (* a[i] = i; cout „„ a[i] «« " "; *) cout «« «\n“; vec b(10,19); for (i=0; i«b.size(); i++) b[i+10] = a[i]; for (i=0; i«b.size(); i++) cout «« b[i+10] «« " "; cout «« «\n“; *)
 Он выдает 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
 Это направление развития векторного типа можно разрабатывать дальше. Довольно просто сделать многомерные массивы, массивы, в которых число размерностей задается как параметр конструктора, массивы в стиле Фортрана, к которым можно одновременно обращаться и как к имеющим две размерности, и как к имеющим три, и т.д.
 Так класс управляет доступом к некоторым данным. Поскольку весь доступ осуществляется через интерфейс, обеспеченный открытой частью класса, то можно использовать представление данных в соответствие с нуждами разработчика. Например, тривиально можно было бы поменять представление вектора на связанный список. Другая сторона этого состоит в том, что при заданной реализации можно обеспечить любой удобный интерфейс.




 1.14 Еще об операциях


 Другое направление развития – снабдить вектора операциями:
 class Vec : public vector (* public: Vec(int s) : (s) (**) Vec(Vec amp;); ~Vec() (**) void operator=(Vec amp;); void operator*=(Vec amp;); void operator*=(int); //... *);
 Обратите внимание на способ определения конструктора производного класса, Vec::Vec(), когда он передает свой параметр конструктору базового класса vector::vector() и больше не делает ничего. Это полезная парадигма. Операция присваивания перегружена, ее можно определить так:
 void Vec::operator=(Vec amp; a) (* int s = size(); if (s!=a.size()) error(«bad vector size for =»); // плохой размер вектора для = for (int i = 0; i«s; i++) elem(i) = a.elem(i); *)
 Присваивание объектов класса Vec теперь действительно копирует элементы, в то время как присваивание объектов
 vector просто копирует структуру, управляющую доступом к элментам. Последнее, однако, происходит и тогда, когда vector копируется без явного использования операции присваивания: (1) когда vector передается как параметр и (3) когда vector передается как значение, возвращаемое функцией. Чтобы обрабатывать эти случаи для векторов Vec, вы определяете конструктор Vec(Vec amp;): Vec::Vec(Vec amp; a) : (a.size()) (* int sz = a.size(); for (int i = 0; i«sz; i++) elem(i) = a.elem(i); *) Этот конструктор инициализирует Vec как копию другого Vec, и будет вызываться в отмеченных выше случаях. Выражение в левой части таких операций, как = и +=, безусловно определено, поэтому кажется вполне естественным реализовать их как операции над объектом, который обозначается (денотируется) этим выражением. В частности, тогда они смогут изменять значение своего первого операнда. Левый операнд таких операций, как + и – не требует особого внимания. Вы могли бы, например, передавать оба аргумента по значению и все рано получить правильную реализацию векторного сложения. Однако вектора могут оказаться большими, поэтому чтобы избежать ненужного копирования операнды операции + передаются в operator +() по ссылке:
 Vec operator+(Vec amp; a,Vec amp;b) (* int s = a.size(); if (s != b.size()) error(«bad vector size for +»); // плохой размер вектора для + Vec sum(s); for (int i=0; i«s; i++) sum.elem(i) = a.elem(i) + b.elem(i); return sum; *)
 Вот пример небольшой программы, которую можно выполнить, если скомпилировать ее вместе с ранее приведенными описаниями vector:
 #include «stream.h»
 void error(char* p) (* cerr «„ p «« «\n“; exit(1); *)
 void vector::set_size(int) (* /*...*/ *)
 int amp; vec::operator[](int i) (* /*...*/ *)
 main() (* Vec a(10); Vec b(10); for (int i=0; i«a.size(); i++) a[i] = i; b = a; Vec c = a+b; for (i=0; i„c.size(); i++) cout «« c[i] «« «\n“; *)




 1.15 Друзья (friend)


 Функция operator+() не воздействует непосредственно на представление вектора. Действительно, она не может этого делать, поскольку не является членом. Однако иногда желательно дать функциям не членам возможность доступа к закрытой части класса. Например, если бы не было функции «доступа без проверки» vector::elem(), вам пришлось бы проверять индекс i на соответствие границам три раза за каждый проход цикла. Здесь мы избежали этой сложности, но она довольно типична, поэтому у класса есть механизм предоставления права доступа к своей закрытой части функциям не членам. Просто в класс помещается описание функции, перед которым стоит ключевое слово friend. Например, если имеется
 class Vec; // Vec – имя класса class vector (* friend Vec operator+(Vec, Vec); //... *);
 То вы можете написать Vec operator+(Vec a, Vec b) (* int s = a.size(); if (s != b.size()) error(«bad vector size for +»); // плохой размер вектора для + Vec amp; sum = *new Vec(s); int* sp = sum.v; int* ap = a.v; int* bp = b.v; while (s–) *sp++ = *ap++ + *bp++; return sum; *)
 Одним из особенно полезных аспектов механизма friend является то, что функция может быть другом двух и более классов. Чтобы увидеть это, рассмотрим определение vector и matrix, а затем определение функции умножения (см. #с.8.8).
 1.16 Обобщенные Вектора
 «Пока все хорошо,» – можете сказать вы, – «но я хочу, чтобы один из этих векторов был типа matrix, который я только что определил.» К сожалению, в С++ не предусмотрены средства для определения класса векторов с типом элемента в качестве параметра. Один из способов – продублировать описание и класса, и его функций членов. Это не идеальный способ, но зачатую вполне приемлемый.
 Вы можете воспользоваться препроцессором (#4.7), чтобы механизировать работу. Например, класс vector – упрощенный вариант класса, который можно найти в стандартном заголовочном файле. Вы могли бы написать:
 #include «vector.h»
 declare(vector,int);
 main() (* vector(int) vv(10); vv[2] = 3; vv[10] = 4; // ошибка: выход за границы *)
 Файл vector.h таким образом определяет макросы, чтобы макрос declare(vector,int) после расширения превращался в описание класса vector, очень похожий на тот, который был определен выше, а макрос implement(vector,int) расширялся в определение функций этого класса. Поскольку макрос implement(vector,int) в результате расширения превращается в
 определение функций, его можно использовать в программе только один раз, в то время как declare(vector,int) должно использоваться по одному разу в каждом файле, работающем с этим типом целых векторов.
 declare(vector,char); //... implement(vector,char);
 даст вам отдельный тип «вектор символов». Пример реализации обобщенных классов с помощью макросов приведен в #7.3.5.




 1.17 Полиморфные Вектора


 У вас есть другая возможность – определить ваш векторный и другие вмещающие классы через указатели на объекты некоторого класса: class common (* //... *); class vector (* common** v; //... public: cvector(int); common* amp; elem(int); common* amp; operator[](int); //... *);
 Заметьте, что поскольку в таких векторах хранятся указатели, а не сами объекты, объект может быть "в" нескольких таких векторах одновременно. Это очень полезное свойство подобных вмещающих классов, таких, как вектора, связанные списки, множества и т.д. Кроме того, можно присваивать указатель на производный класс указателю на его базовый класс, поэтому можно использовать приведенный выше cvector для хранения указателей на объекты всех производных от common классов. Например:
 class apple : public common (* /*...*/ *) class orange : public common (* /*...*/ *) class apple_vector : public cvector (* public:
 cvector fruitbowl(100); //... apple aa; orange oo; //... fruitbowl[0] = amp;aa; fruitbowl[1] = amp;oo; *)
 Однако, точный тип объекта, вошедшего в такой вмещающий класс, больше компилятору не известен. Например, в предыдущем примере вы знаете, что элемент вектора является common, но является он apple или orange? Обычно точный тип должен впоследствии быть восстановлен, чтобы обеспечить правильное использование объекта. Для этого нужно или в какой-то форме хранить информацию о типе в самом объекте, или обеспечить, чтобы во вмещающий класс помещались только объекты данного типа. Последнее легко достигается с помощью производного класса. Вы можете, например, создать вектор указателей на apple:
 class apple_vector : public cvector (* public: apple* amp; elem(int i) (* return (apple* amp;) cvector::elem(i); *) //... *);
 используя запись приведения к типу (тип)выражение, чтобы преобразовать common* amp; (ссылку на указатель на common), которую возвращает cvector::elem, в apple* amp;. Такое применение производных классов создает альтернативу обобщенным классам. Писать его немного труднее (если не использовать макросы таким образом, чтобы производные классы фактически реализовывали обобщенные классы, см. #7.3.5), но оно имеет то преимущество, что все производные классы совместно используют единственную копию функции базового класса. В случае обобщенных классов, таких, как vector(type), для каждого нового используемого типа должна создаваться (с помощью implement()) новая копия таких функций. Другой способ, хранение идентификации типа в каждом объекте, приводит нас к стилю программирования, который часто называют объекто-основанным или объектно-ориентированным.




 1.18 Виртуальные Функции


 Предположим, что мы пишем программу для изображения фигур на экране. Общие атрибуты фигуры представлены классом shape, а специальные атрибуты – специальными классами:
 class shape (* point center; color col; //... public: void move(point to) (* center=to; draw(); *) point where() (* return center; *) virtual void draw(); virtual void rotate(int); //... *);
 Функции, которые можно определить не зная точно определенной фигуры (например, move и where, то есть, «передвинуть» и «где»), можно описать как обычно. Остальные функции описываются как virtual, то есть такие, которые должны определяться в производном классе. Например:
 class circle: public shape (* int radius; public: void draw(); void rotatte(int i) (**) //... *);
 Теперь, если shape_vec – вектор фигур, то можно написать:
 for (int i = 0; i«no_of_shapes; i++) shape_vec[i].rotate(45);
 чтобы повернуть все фигуры на 45 градусов (и заново нарисовать)
 Такой стиль особенно полезен в интерактивных программах, когда объекты разных типов одинаково обрабатываются основным
 программным обеспечением. Ведь по сути дела, типичное действие пользователя – это ткнуть в какой-нибудь объект и сказать Кто ты? Что ты такое? и Делай, что надо! не давая никакой информации о типе. Программа может и должна уяснить это для себя сама.




 Глава 2 Описания и Константы



 Совершенство достигается только к моменту краха.

    С.Н. Паркинсон

 В этой главе описаны основные типы (char, int, float и т.д.) и основные способы построения из них новых типов (функций, векторов, указателей и т.д.). Имя вводится в программе посредством описания, которое задает его тип и, возможно, начальное значение. Даны понятия описания, определения, области видимости имен, времени жизни объектов и типов. Описываются способы записи констант в С++, а также способы определения символических констант. Примеры просто демонстрируют характерные черты языка. Более развернутый и реалистичный пример приводится в следующей главе для знакомства с выражениями и операторами языка С++. Механизмы задания типов, определяемых пользователем, с присоединенными операциями представлены в Главах 4, 5 и 6 и здесь не упоминаются.




 2.1 Описания


 Прежде чем имя (идентификатор) может быть использовано в С++ программе, он должно быть описано. Это значит, что надо задать его тип, чтобы сообщить компилятору, к какого вида сущностям относится имя. Вот несколько примеров, иллюстрирующих разнообразие описаний:
 char ch; int count = 1; char* name = «Bjarne»; struct complex (* float re, im; *); complex cvar; extern complex sqrt(complex); extern int error_number; typedef complex point; float real(complex* p) (* return p-»re; *); const double pi = 3.1415926535897932385; struct user;
 Как можно видеть из этих примеров, описание может делать больше чем просто ассоциировать тип с именем. Большинство описаний являются также определениями то есть они также определяют для имени сущность, к которой оно относится. Для ch, count и cvar этой сущностью является соответствующий объем памяти, который должен использоваться как переменная – эта память будет выделена. Для real это заданная функция. Для constant pi это значение 3.1415926535897932385. Для complex этой сущностью является новый тип. Для point это тип complex, поэтому point становится синонимом complex. Только описания
 extern complex sqrt(complex); extern int error_number; struct user;
 не являются одновременно определениями. Это означает, что объект, к которому они относятся, должен быть определен где-то еще. Код (тело) функции sqrt должен задаваться неким другим описанием, память для переменной error_number типа int должна выделяться неким другим описанием, и какое-то другое описание типа user должно определять, что он из себя представляет. В С++ программе всегда должно быть только одно определение каждого имени, но описаний может быть много, и все описания должны согласовываться с типом объекта, к которому они относятся, поэтому в этом фрагменте есть две ошибки:
 int count; int count; // ошибка: переопределение extern int error_number; extern int error_number; // ошибка: несоответствие типов
 а в этом – ни одной (об использовании extern см. #4.2):
 extern int error_number; extern int error_number;
 Некоторые описания задают «значение» для сущностей, которые они определяют:
 struct complex (* float re, im; *); typedef complex point; float real(complex* p) (* return p-»re *); const double pi = 3.1415926535897932385;
 Для типов, функций и констант «значение» неизменно. Для неконстантных типов данных начальное значение может впоследствии изменяться:
 int count = 1; char* name = «Bjarne»; //... count = 2; name = «Marian»;
 Из всех определений только
 char ch;
 не задает значение. Всякое описание, задающее значение, является определением.




 2.1.1 Область Видимости


 Описание вводит имя в области видимости. То есть, имя может использоваться только в определенной части программы. Для имени, описанного в функции (такое имя часто называют локальным), эта область видимости простирается от точки описания до конца блока, в котором появилось описание. Для имени не в функции и не в классе (называемого часто глобально видимым именем) область видимости простирается от точки описания до конца файла, в котором появилось описание. Описание имени в блоке может скрывать (прятать) описание во внутреннем блоке или глобальное имя. Это значит, что можно переопределять имя внутри блока для ссылки на другой объект. После выхода из блока имя вновь обретает свое прежнее значение. Например:
 int x; // глобальное x
 f() (* int x; // локальное x прячет глобальное x x = 1; // присвоить локальному x (* int x; // прячет первое локальное x x = 2; // присвоить второму локальному x *) x = 3; // присвоить первому локальному x *)
 int* p = amp;x; // взять адрес глобального x
 Сокрытие имен неизбежно при написании больших программ. Однако читающий человек легко может не заметить, что имя скрыто, и некоторые ошибки, возникающие вследствие этого,
 очень трудно обнаружить, главным образом потому, что они редкие. Значит сокрытие имен следует минимизировать. Использование для глобальных переменных имен вроде i или x напрашиваемся на неприятности.
 С помощью применения операции разрешения области видимости :: можно использовать скрытое глобальное имя. Например:
 int x;
 f() (* int x = 1; // скрывает глобальное x ::x = 2; // присваивает глобальному x *)
 Но возможности использовать скрытое локальное имя нет.
 Область видимости имени начинается в точке описания. Это означает, что имя можно использовать даже для задания его собственного значения. Например:
 int x;
 f() (* int x = x; // извращение *)
 Это не является недопустимым, хотя и бессмысленно, и компилятор предупредит, что x «used before set» («использовано до того, как задано»), если вы попробуете так сделать. Можно, напротив, не применяя операцию ::, использовать одно имя для ссылки на два различных объекта в блоке. Например:
 int x;
 f() // извращение (* int y = x; // глобальное x int x = 22; y = x; // локальное x *)
 Переменная y инициализируется значением глобального x, 11, а затем ему присваивается значение локальной переменной x, 22.
 Имена параметров функции считаются описанными в самом внешнем блоке функции, поэтому
 f(int x) (* int x; // ошибка *)
 содержит ошибку, так как x определено дважды в одной и той же области видимости.




 2.1.2 Объекты и Адреса (Lvalue)


 Можно назначать и использовать переменные, не имеющие имен, и можно осуществлять присваивание выражениям странного вида (например, *p[a+10]=7). Следовательно, есть потребность в имени «нечто в памяти». Вот соответствующая цитата из справочного руководства по С++: "Объект есть область памяти.
 lvalue есть выражение, ссылающееся на объект" (#с.5). Слово «lvalue» первоначально было придумано для значения «нечто, что может стоять в левой части присваивания». Однако не всякое lvalue можно использовать в левой части присваивания; бывают lvalue, ссылающиеся на константу (см. #2.4).




 2.1.3 Время Жизни


 Если программист не указал иного, то объект создается, когда встречается его описание, и уничтожается, когда его имя выходит из области видимости, Объекты с глобальными именами создаются и инициализируются один раз (только) и «живут» до завершения программы. Объекты, определенные описанием с ключевым словом static, ведут себя так же. Например*:
 – * Команда #include «stream.h» была выброшена из примеров в этой главе для экономии места. Она необходима в примерах, производящих вывод, чтобы они были полными. (прим. автора)
 int a = 1;
 void f() (* int b = 1; // инициализируется при каждом // вызове f() static int c = 1; // инициализируется только один раз cout «„ " a = " «« a++ «« " b = " «« b++ «« " c = " «« c++ «« «\n“; *)
 main() (* while (a « 4) f(); *)
 производит вывод
 a = 1 b = 1 c = 1 a = 2 b = 1 c = 2 a = 3 b = 1 c = 3
 Не инициализированная явно статическая (static) переменная неявно инициализируется нулем.
 С помощью операций new и delete программист может также создавать объекты, время жизни которых управляется непосредственно, см. #3.2.4.




 2.2 Имена


 Имя (идентификатор) состоит из последовательности букв и цифр. Первый символ должен быть буквой. Символ подчерка _ считается буквой. С++ не налагает ограничений на число символов в имени, но некоторые части реализации находятся вне ведения автора компилятора (в частности, загрузчик), и они, к сожалению, такие ограничения налагают. Некоторые среды выполнения также делают необходимым расширить или ограничить набор символов, допустимых в идентификаторе. Расширения (например, при допущении в именах символа $) порождают непереносимые программы. В качестве имени не могут использоваться ключевые слова С++ (см. #с.2.3). Примеры имен:
 hello this_is_a_most_unusially_long_name DEFINED foO bAr u_name HorseSense var0 var1 CLASS _class ___
 Примеры последовательностей символов, которые не могут использоваться как идентификаторы:
 012 a fool $sys class 3var pay.due foo~bar .name if
 Буквы в верхнем и нижнем регистрах считаются различными, поэтому Count и count – различные имена, но вводить имена, лишь незначительно отличающиеся друг от друга, нежелательно. Имена, начинающиеся с подчерка, по традиции используются для специальных средств среды выполнения, поэтому использовать такие имена в прикладных программах нежелательно.
 Во время чтения программы компилятор всегда ищет наиболее длинную строку, составляющую имя, поэтому var10 – это оно имя, а не имя var, за которым следует число 10, и elseif – одно имя, а не ключевое слово else, после которого стоит ключевое слово if.




 2.3 Типы


 Каждое имя (идентификатор) в С++ программе имеет ассоциированный с ним тип. Этот тип определяет, какие операции моно применять к имени (то есть к объекту, на который оно ссылается), и как эти операции интерпретируются. Например:
 int error number; float real(complex* p);
 Поскольку error_number описано как int, его можно присваивать, использовать в арифметических выражениях и т.д. Тогда как функция real может вызываться с адресом complex в качестве параметра. Можно взять адрес любого из них. Некоторые имена, вроде int и complex, являются именами типов. Обычно имя типа используется в описании для спецификации другого имени. Единственные отличные от этого действия над именем типа – это sizeof (для определения количества памяти, которая требуется для хранения объекта типа) и new (для размещения объекта типа в свободной памяти). Например:
 main() (* int* p = new int; cout «„ "sizeof(int) = " «« sizeof(int) «\n“; *)
 Имя типа можно также использовать для задания явного преобразования одного типа в другой, например:
 float f; char* p; //... long ll = long(p); // преобразует p в long int i = int(f); // преобразует f в int




 2.3.1 Основные Типы


 В С++ есть набор основных типов, которые соответствуют наиболее общим основным единицам памяти компьютера и наиболее общим основным способам их использования:
 char short int int long int
 для представления целых различных размеров,
 float double
 для представления чисел с плавающей точкой,
 unsigned char unsigned short int unsigned int unsigned long int
 для представления беззнаковых целых, логических значений, битовых массивов и т.п. Для большей компактности записи можно опускать int в комбинациях из нескольких слов, что не меняет смысла. Так, long означает long int, и unsigned тип означает тип unsigned int. В общем, когда в описании опущен тип, он предполагается int. Например:
 const a = 1; static x;
 все определяют объект типа int.
 Целый тип char наиболее удобен для хранения и обработки символов на данном компьютере, обычно это 8-битовый байт. Размеры объектов С++ выражаются в единицах размера char, потому по определению sizeof(char)==1. В зависимости от аппаратного обеспечения char является знаковым или беззнаковым целым. Тип unsigned char, конечно, всегда беззнаковый, и при его использовании получаются более переносимые программы, но из-за применения его вместо просто char могут возникать значительные потери в эффективности.
 Причина того, что предоставляется более чем один целый тип, более чем один беззнаковый тип и более чем один тип с плавающей точкой, в том, чтобы дать возможность программисту воспользоваться характерными особенностями аппаратного обеспечения. На многих машинах между различными разновидностями основных типов существуют значительные различия в потребностях памяти, временах доступа к памяти и временах вычислений. Зная машину обычно легко, например, выбрать подходящий тип для конкретной переменной. Написать действительно переносимую программу нижнего уровня сложнее. Вот все, что гарантируется относительно размеров основных типов:
 1==sizeof(char)«=sizeof(short)«= sizeof(int)«=sizeof(long) sizeof(float)«=sizeof(double)
 Однако обычно разумно предполагать, что в char могут храниться целые числа в диапазоне 0..127 (в нем всегда могут храниться символы машинного набора символов), что short и int имеют не менее 16 бит, что int имеет размер, соответствующий целой арифметике, и что long имеет по меньшей мере 24 бита. Предполагать что-либо помимо этого рискованно, и даже эти эмпирические правила применимы не везде. Таблицу характеристик аппаратного обеспечения для некоторых машин можно найти в #с. 2.6.
 Беззнаковые (unsigned) целые типы идеально подходят для применений, в которых память рассматривается как массив битов. Использование unsigned вместо int с тем, чтобы получить еще один бит для представления положительных целых, почти никогда не оказывается хорошей идеей. Попытки гарантировать то, что некоторые значения положительны, посредством описания переменных как unsigned, обычно срываются из-за правил неявного преобразования. Например:
 unsigned surprise = -1;
 допустимо (но компилятор обязательно сделает предупреждение).




 2.3.2 Неявное Преобразование Типа


 Основные типы можно свободно сочетать в присваиваниях и выражениях. Везде, где это возможно, значения преобразуются так, чтобы информация не терялась. Точные правила можно найти в #с.6.6.
 Существуют случаи, в которых информация может теряться или искажаться. Присваивание значения одного типа переменной другого типа, представление которого содержит меньшее число бит, неизбежно является источником неприятностей. Допустим, например, что следующая часть программы выполняется на машине с двоичным дополнительным представлением целых и 8-битовыми символами:
 int i1 = 256+255; char ch = i1 // ch == 255 int i2 = ch; // i2 == ?
 В присваивании ch=i1 теряется один бит (самый значимый!), и ch будет содержать двоичный код «все-единицы» (т.е. 8 единиц); при присваивании i2 это никак не может превратится в 511! Но каким же может быть значение i2? На DEC VAX, где char знаковое, ответ будет -1, на AT amp;T 3B-20, где char беззнаковые, ответ будет 255. В С++ нет динамического (т.е. действующего во время исполнения) механизма для разрешения такого рода проблем, а выяснение на стадии компиляции вообще очень сложно, поэтому программист должен быть внимателен.




 2.3.3 Производные Типы


 Другие типы можно выводить из основных типов (и типов, определенных пользователем) посредством операций описания:
 * указатель amp; ссылка [] вектор () функция
 и механизма определения структур. Например:
 int* a; float v[10]; char* p[20]; // вектор из 20 указателей на символ void f(int); struct str (* short length; char* p; *);
 Правила построения типов с помощью этих операций подробно объясняются в #с.8.3-4. Основная идея состоит в том, что описание производного типа отражает его использование. Например:
 int v[10]; // описывает вектор i = v[3]; // использует элемент вектора
 int* p; // описывает указатель i = *p; // использует указываемый объект
 Вся сложность понимания записи производных типов проистекает из того, что операции * и amp; префиксные, а операции [] () постфиксные, поэтому для формулировки типов в тех случаях, когда приоритеты операций создают затруднения, надо использовать скобки. Например, поскольку приоритет у [] выше, чем у *, то
 int* v[10]; // вектор указателей int (*p)[10]; // указатель на вектор
 Большинство людей просто помнят, как выглядят наиболее обычные типы.
 Описание каждого имени, вводимого в программе, может оказаться утомительным, особенно если их типы одинаковы. Но можно описывать в одном описании несколько имен. В этом случае описание содержит вместо одного имени список имен, разделенных запятыми. Например, два имени можно описать так:
 int x, y; // int x; int y;
 При описании производных типов можно указать, что операции применяются только к отдельным именам (а не ко всем остальным именам в этом описании). Например:
 int* p, y; // int* p; int y; НЕ int* y; int x, *p; // int x; int* p; int v[10], *p; // int v[10]; int* p;
 Мнение автора таково, что подобные конструкции делают программу менее удобочитаемой, и их следует избегать.




 2.3.4 Тип void


 Тип void (пустой) синтаксически ведет себя как основной тип. Однако использовать его можно только как часть производного типа, объектов типа void не существует. Он используется для того, чтобы указать, что функция не возвращает значения, или как базовый тип для указателей на объекты неизвестного типа.
 void f() // f не возвращает значение void* pv; // указатель на объект неизвестного типа
 Переменной типа указатель на void (void *), можно присваивать указатель любого типа. На первый взгляд это может показаться не особенно полезным, поскольку void* нельзя разименовать, но именно это ограничение и делает тип void* полезным. Главным образом, он применяется для передачи указателей функциям, которые не позволяют сделать предположение о типе объекта, и для возврата из функций нетипизированных объектов. Чтобы использовать такой объект, необходимо применить явное преобразование типа. Подобные функции обычно находятся на самом нижнем уровне системы, там, где осуществляется работа с основными аппаратными ресурсами. Например:
 void* allocate(int size); // выделить void deallocate(void*); // освободить
 f() (* int* pi = (int*)allocate(10*sizeof(int)); char* pc = (char*)allocate(10); //... deallocate(pi); deallocate(pc); *)




 2.3.5 Указатели


 Для большинства типов T T* является типом арифметический указатель на T. То есть, в переменной типа T* может храниться адрес объекта типа T. Для указателей на вектора и указателей на функции вам, к сожалению, придется пользоваться более сложной записью:
 int* pi; char** cpp; // указатель на указатель на char int (*vp)[10]; // указатель на вектор из 10 int'ов int (*fp)(char, char*); // указатель на функцию //получающую параметры(char, char*) // и возвращающую int
 Основная операция над указателем – разыменование, то есть ссылка на объект, на который указывает указатель. Эта операция также называется косвенным обращением. Операция разыменования – это унарное * (префиксное). Например:
 char c1 = 'a'; char* p = amp;c1; // в p хранится адрес c1 char c2 = *p; // c2 = 'a'
 Переменная, на которую указывает p,– это c1, а значение, которое хранится в c1, это 'a', поэтому присваиваемое c2 значение *p есть 'a'.
 Над указателями можно осуществлять некоторые арифметические действия. Вот, например, функция, подсчитывающая число символов в строке (не считая завершающего 0):
 int strlen(char* p) (* int i = 0; while (*p++) i++; return i; *)
 Другой способ найти длину состоит в том, чтобы сначала найти конец строки, а затем вычесть адрес начала строки из адреса ее конца:
 int strlen(char* p) (* char* q = p; while (*q++) ; return q-p-1; *)
 Очень полезными могут оказаться указатели на функции. Они обсуждаются в #4.6.7.




 2.3.6 Вектора


 Для типа T T[size] является типом «вектор из size элементов типа T». Элементы индексируются (нумеруются) от 0 до size-1. Например:
 float v[3]; // вектор из трех float: v[0], v[1], v[2] int a[2][5]; // два вектора из пяти int char* vpc; // вектор из 32 указателей на символ
 Цикл для печати целых значений букв нижнего регистра можно было бы написать так:
 extern int strlen(char*);
 char alpha[] = «abcdefghijklmnoprstuvwxyz»;
 main()
 (* int sz = strlen(alpha);
 for (int i=0; i«sz; i++) (* char ch = alpha[i]; cout „„ "'" „« chr(ch) «« "'" «« " = " «« ch «« « = 0“ «« oct(ch) «« « = 0x“ «« hex(ch) «« «\n“; *) *)
 Функция chr() возвращает представление небольшого целого в виде строки; например, chr(80) это "P" на машине, на которой используется набор символов ASCII. Функция oct() строит восьмеричное представление своего целого аргумента, а hex() строит шестнадцатеричное представление своего целого аргумента; chr() oct() и hex() описаны в «stream.h». Функция strlen() использовалась для подсчета числа символов в alpha; вместо этого можно было использовать значение размера alpha (#2.4.4). Если применяется набор символов ASCII, то выдача выглядит так:
 'a' = 97 = 0141 = 0x61 'b' = 98 = 0142 = 0x62 'c' = 99 = 0143 = 0x63 ...
 Заметим, что задавать размер вектора alpha необязательно. Компилятор считает число символов в символьной строке, указанной в качестве инициализатора. Использование строки как инициализатора для вектора символов – удобное, но к сожалению и единственное применение строк. Аналогичное этому присваивание строки вектору отсутствует. Например:
 char v[9]; v = «строка»; // ошибка
 ошибочно, поскольку присваивание не определено для векторов.
 Конечно, для инициализации символьных массивов подходят не только строки. Для остальных типов нужно применять более сложную запись. Эту запись можно использовать и для символьных векторов. Например:
 int v1[] = (* 1, 2, 3, 4 *); int v2[] = (* 'a', 'b', 'c', 'd' *);
 char v3[] = (* 1, 2, 3, 4 *); char v4[] = (* 'a', 'b', 'c', 'd' *);
 Заметьте, что v4 – вектор из четырех (а не пяти) символов; он не оканчивается нулем, как того требуют соглашение и библиотечные подпрограммы. Обычно применение такой записи ограничивается статическими объектами.
 Многомерные массивы представляются как вектора векторов, и применение записи через запятую, как это делается в некоторых других языках, дает ошибку при компиляции, так как запятая (,) является операцией следования (см. #3.2.2). Попробуйте, например, сделать так:
 int bad[5,2]; // ошибка
 и так:
 int v[5][2];
 int bad = v[4,1]; // ошибка int good = v[4][1]; // ошибка
 Описание
 char v[2][5];
 описывает вектор из двух элементов, каждый из которых является вектором типа char[5]. В следующем примере первый из этих векторов инициализируется первыми пятью буквами, а второй – первыми пятью цифрами.
 char v[2][5] = (* 'a', 'b', 'c', 'd', 'e', '0', '1', '2', '3', '4' *)
 main() (* for (int i = 0; i«2; i++) (* for (int j = 0; j„5; j++) cout „„ „v[“ «« i «« «][“ «« j «« «]=“ «« chr(v[i][j]) «« " "; cout «« «\n“; *) *)
 это дает в результате
 v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4




 2.3.7 Указатели и Вектора


 Указатели и вектора в С++ связаны очень тесно. Имя вектора можно использовать как указатель на его первый элемент, поэтому пример с алфавитом можно было написать так:
 char alpha[] = «abcdefghijklmnopqrstuvwxyz»; char* p = alpha; char ch;
 while (ch = *p++) cout «„ chr(ch) „« " = " «« ch «« « = 0“ «« oct(ch) «« «\n“;
 Описание p можно было также записать как
 char* p = amp;alpha[0];
 Эта эквивалентность широко используется в вызовах функций, в которых векторный параметр всегда передается как указатель на первый элемент вектора. Так, в примере
 extern int strlen(char*); char v[] = «Annemarie»; char* p = v; strlen(p); strlen(v);
 функции strlen в обоих вызовах передается одно и то же значение. Вся штука в том, что этого невозможно избежать; то есть не существует способа описать функцию так, чтобы вектор v в вызове функции копировался (#4.6.3). Результат применения к указателям арифметических операций +, -, ++ или – зависит от типа объекта, на который они указывают. Когда к указателю p типа T* применяется арифметическая операция, предполагается, что p указывает на элемент вектора объектов типа T; p+1
 означает следующий элемент этого вектора, а p предыдущий элемент. Отсюда следует, что значение p+1 будет на sizeof(T) больше значения p. Например, выполнение
 main() (* char cv[10]; int iv[10];
 char* pc = cv; int* pi = iv;
 cout «„ "char* " „« long(pc+1)-long(pc) «« «\n“; cout «« "int* " «« long(ic+1)-long(ic) «« «\n“; *)
 дает
 char* 1 int* 4
 поскольку на моей машине каждый символ занимает один байт, а каждое целое занимает четыре байта. Перед вычитанием значения указателей преобразовывались к типу long с помощью явного преобразования типа (#3.2.5). Они преобразовывались к long, а не к «очевидному» int, поскольку есть машины, на которых указатель не влезет в int (то есть, sizeof(int)«sizeof(long) ).
 Вычитание указателей определено только тогда, когда оба указателя указывают на элементы одного и того же вектора (хотя в языке нет способа удостовериться, что это так). Когда из одного указателя вычитается другой, результатом является число элементов вектора между этими указателями (целое число). Можно добавлять целое к указателю или вычитать целое из указателя; в обоих случаях результатом будет значение типа указателя. Если это значение не указывает на элемент того же вектора, на который указывал исходный указатель, то результат использования этого значения неопределён. Например:
 int v1[10]; int v2[10];
 int i = amp;v1[5]– amp;v1[3]; // 2 i = amp;v1[5]– amp;v2[3]; // результат неопределен
 int* p = v2+2; // p == amp;v2[2] p = v2-2; // p неопределено




 2.3.8 Структуры


 Вектор есть совокупность элементов одного типа, struct является совокупностью элементов (практически) произвольных типов. Например:
 struct address (* // почтовый адрес char* name; // имя «Jim Dandy» long number; // номер дома 61 char* street; // улица «South Street» char* town; // город «New Providence» char* state[2]; // штат 'N' 'J' int zip; // индекс 7974 *)
 определяет новый тип, названный address (почтовый адрес), состоящий из пунктов, требующихся для того, чтобы послать кому-нибудь корреспонденцию (вообще говоря, address не
 является достаточным для работы с полным почтовым адресом, но в качестве примера достаточен). Обратите внимание на точку с запятой в конце; это одно из очень немногих мест в С++, где необходимо ставить точку с запятой после фигурной скобки, поэтому люди склонны забывать об этом.
 Переменные типа address могут описываться точно также, как другие переменные, а доступ к отдельным членам получается с помощью операции . (точка). Например:
 address jd; jd.name = «Jim Dandy»; jd.number = 61;
 Запись, которая использовалась для инициализации векторов, можно применять и к переменным структурных типов. Например:
 address jd = (* «Jim Dandy», 61, «South Street», «New Providence», (*'N','J'*), 7974 *);
 Однако обычно лучше использовать конструктор (#5.2.4). Заметьте, что нельзя было бы инициализировать jd.state строкой «NJ». Строки оканчиваются символом '\0', поэтому в «NJ» три символа, то есть на один больше, чем влезет в jd.state.
 К структурным объектам часто обращаются посредством указателей используя операцию -». Например:
 void print_addr(address* p) (* cout «„ p-“name „„ „\n“ „„ p-“number „„ " " „„ p-“street „« «\n“ «« p-“town «« «\n“ «« chr(p-“state[0]) «« chr(p-“state[1]) «« " " «« p-“zip «« «\n“; *)
 Объекты типа структура можно присваивать, передавать как параметры функции и возвращать из функции в качестве результата. Например:
 address current;
 address set_current(address next) (* address prev = current; current = next; return prev; *)
 Остальные осмысленные операции, такие как сравнение (== и !=) не определены. Однако пользователь может определить эти операции, см. Главу 6. Размер объекта структурного типа нельзя вычислить просто как сумму его членов. Причина этого состоит в том, что многие машины требуют, чтобы объекты определенных типов выравнивались в памяти только по некоторым зависящим от архитектуры границам (типичный пример: целое должно быть выровнено по границе слова), или просто гораздо более эффективно обрабатывают такие объекты, если они выровнены в машине. Это приводит к «дырам» в структуре. Например, (на моей машине) sizeof(address) равен 24, а не 22, как можно было ожидать.
 Заметьте, что имя типа становится доступным сразу после того, как оно встретилось, а не только после того, как полностью просмотрено все описание. Например:
 struct link(* link* previous; link* successor; *)
 Новые объекты структурного типа не могут быть описываться, пока все описание не просмотрено, поэтому
 struct no_good (* no_good member; *);
 является ошибочным (компилятор не может установить размер no_good). Чтобы дать возможность двум (или более) структурным типам ссылаться друг на друга, можно просто описать имя как имя структурного типа. Например:
 struct list; // должна быть определена позднее
 struct link (* link* pre; link* suc; link* member_of; *);
 struct list (* link* head; *)
 Без первого описания list описание link вызвало бы к синтаксическую ошибку.




 2.3.9 Эквивалентность типов


 Два структурных типа являются различными даже когда они имеют одни и те же члены. Например:
 struct s1 (* int a; *); struct s2 (* int a; *);
 есть два разных типа, поэтому
 s1 x; s2 y = x; // ошибка: несоответствие типов
 Структурные типы отличны также от основных типов, поэтому
 s1 x; int i = x; // ошибка: несоответствие типов
 Однако существует механизм для описания нового имени для типа без введения нового типа. Описание с префиксом typedef описывает не новую переменную данного типа, а новое имя этого типа. Например:
 typedef char* Pchar; Pchar p1, p2; char* p3 = p1;
 Это может служить удобной сокращенной записью.




 2.3.10 Ссылки


 Ссылка является другим именем объекта. Главное применение ссылок состоит в спецификации операций для типов, определяемых пользователем; они обсуждаются в Главе 6. Они могут также быть полезны в качестве параметров функции. Запись x amp; означает ссылка на x. Например:
 int i = 1; int amp; r = i; // r и i теперь ссылаются на один int int x = r // x = 1 r = 2; // i = 2;
 Ссылка должна быть инициализирована (должно быть что-то, для чего она является именем). Заметьте, что инициализация ссылки есть нечто совершенно отличное от присваивания ей.
 Вопреки ожиданиям, ни одна операция на ссылку не действует. Например:
 int ii = 0; int amp; rr = ii; rr++; // ii увеличивается на 1
 допустимо, но rr++ не увеличивает ссылку; вместо этого + + применяется к int, которым оказывается ii. Следовательно, после инициализации значение ссылки не может быть изменено; она всегда ссылается на объект, который ей было дано обозначать (денотировать) при инициализации. Чтобы получить указатель на объект, денотируемый ссылкой rr, можно написать amp;rr.
 Очевидным способом реализации ссылки является константный указатель, который разыменовывается при каждом использовании. Это делает инициализацию ссылки тривиальной, когда инициализатор является lvalue (объектом, адрес которого вы можете взять, см. #с.5). Однако инициализатор для amp;T не обязательно должен быть lvalue, и даже не должен быть типа T. В таких случаях:
 1. Во-первых, если необходимо, применяется преобразование типа (#с.6.6-8, #с.8.5.6),
 2. Затем полученное значение помещается во временную переменную и
 3. Наконец, ее адрес используется в качестве значения инициализатора.
 Рассмотрим описание
 double amp; dr = 1;
 Это интерпретируется так:
 double* drp; // ссылка, представленная как указатель double temp; temp = double(1); drp = amp;temp;
 int x = 1; void incr(int amp; aa) (* aa++; *) incr(x) // x = 2
 По определению семантика передачи параметра та же, что семантика инициализации, поэтому параметр aa функции incr становится другим именем для x. Однако, чтобы сделать программу читаемой, в большинстве случаев лучше всего избегать функций, которые изменяют значение своих параметров. Часто
 предпочтительно явно возвращать значение из функции или требовать в качестве параметра указатель:
 int x = 1; int next(int p) (* return p+1; *) x = next(x); // x = 2
 void inc(int* p) (* (*p)++; *) inc( amp;x); // x = 3
 Ссылки также можно применять для определения функций, которые могут использоваться и в левой, и в правой части присваивания. Опять, большая часть наиболее интересных случаев этого встречается при разработке нетривиальных типов, определяемых пользователем. Для примера давайте определим простой ассоциативный массив. Вначале мы определим структуру пары следующим образом:
 struct pair (* char* name; int val; *);
 Основная идея состоит в том, что строка имеет ассоциированное с ней целое значение. Легко определить функцию поиска find(), которая поддерживает структуру данных, состоящую из одного pair для каждой отличной от других строки, которая была ей представлена. Для краткости представления используется очень простая (и неэффективная) реализация:
 const large = 1024; static pair vec[large+1*);
 pair* find(char* p) /* поддерживает множество пар «pair»: ищет p, если находит, возвращает его «pair», иначе возвращает неиспользованную «pair» */ (* for (int i=0; vec[i].name; i++) if (strcmp(p,vec[i].name)==0) return amp;vec[i];
 if (i == large) return amp;vec[large-1];
 return amp;vec[i]; *)
 Эту функцию может использовать функция value(), реализующая массив целых, индексированный символьными строками (вместо обычного способа):
 int amp; value(char* p) (* pair* res = find(p); if (res-»name == 0) (* // до сих пор не встречалось: res-»name = new char[strlen(p)+1]; // инициализировать strcpy(res-»name,p); res-»val = 0; // начальное значение 0 *) return res-»val; *)
 Для данной в качестве параметра строки value() находит целый объект (а не значение соответствующего целого); после чего она возвращает ссылку на него. Ее можно использовать,
 например, так:
 const MAX = 256; // больше самого большого слова
 main() // подсчитывает число вхождений каждого слова во вводе (* char buf[MAX];
 while (cin»»buf) value(buf)++;
 for (int i=0; vec[i].name; i++) cout «„ vec[i].name «« ": " «« vec [i].val «« «\n“; *)
 На каждом проходе цикл считывает одно слово из стандартной строки ввода cin в buf (см. Главу 8), а затем обновляет связанный с ней счетчик с помощью find(). И, наконец, печатается полученная таблица различных слов во введенном тексте, каждое с числом его встречаемости. Например, если вводится
 aa bb bb aa aa bb aa aa
 то программа выдаст:
 aa: 5 bb: 3
 Легко усовершенствовать это в плане собственного типа ассоциированного массива с помощью класса с перегруженной операцией (#6.7) выбора [].




 2.3.11 Регистры


 Во многих машинных архитектурах можно обращаться к (небольшим) объектам заметно быстрее, когда они помещены в регистр. В идеальном случае компилятор будет сам определять оптимальную стратегию использования всех регистров, доступных на машине, для которой компилируется программа. Однако это нетривиальная задача, поэтому иногда программисту стоит дать подсказку компилятору. Это делается с помощью описания объекта как register. Например:
 register int i; register point cursor; register char* p;
 Описание register следует использовать только в тех случаях, когда эффективность действительно важна. Описание каждой переменной как register засорит текст программы и может даже увеличить время выполнения (обычно воспринимаются все инструкции по помещению объекта в регистр или удалению его оттуда).
 Невозможно получить адрес имени, описанного как register, регистр не может также быть глобальным.




 2.4 Константы


 С++ дает возможность записи значений основных типов: символьных констант, целых констант и констант с плавающей точкой. Кроме того, ноль (0) может использоваться как константа любого указательного типа, и символьные строки являются константами типа char[]. Можно также задавать символические константы. Символическая константа – это имя, значение которого не может быть изменено в его области видимости. В С++ имеется три вида символических констант: (1) любому значению
 любого типа можно дать имя и использовать его как константу, добавив к его описанию ключевое слово const; (2) множество целых констант может быть определено как перечисление; и (3) любое имя вектора или функции является константой.




 2.4.1 Целые Константы


 Целые константы предстают в четырех обличьях: десятичные, восьмеричные, шестнадцатеричные константа и символьные константы. Десятичные используются чаще всего и выглядят так, как можно было бы ожидать:
 0 1234 976 12345678901234567890
 Десятичная константа имеет тип int, при условии, что она влезает в int, в противном случае ее тип long. Компилятор должен предупреждать о константах, которые слишком длинны для представления в машине.
 Константа, которая начинается нулем за которым идет x (0 x), является шестнадцатеричным числом (с основанием 16), а константа, которая начинается нулем за которым идет цифра, является восьмеричным числом (с основанием 8). Вот примеры восьмеричных констант:
 0 02 077 0123
 их десятичные эквиваленты – это 0, 2, 63, 83. В шестнадцатиричной записи эти константы выглядят так:
 0x0 0x2 0x3f 0x53
 Буквы a, b, c, d, e и f, или их эквиваленты в верхнем регистре, используются для представления чисел 10, 11, 12, 13, 14 и 15, соответственно. Восьмеричная и шестнадцатеричная записи наиболее полезны для записи набора битов применение этих записей для выражения обычных чисел может привести к неожиданностям. Например, на машине, где int представляется как двоичное дополнительное шестнадцатеричное целое, 0xffff является отрицательным десятичным числом -1; если бы для представления целого использовалось большее число битов, то оно было бы числом 65535.




 2.4.2 Константы с Плавающей Точкой


 Константы с плавающей точкой имеют тип double. Как и в предыдущем случае, компилятор должен предупреждать о константах с плавающей точкой, которые слишком велики, чтобы их моно было представить. Вот некоторые константы с плавающей точкой:
 1.23 .23 0.23 1. 1.0 1.2e10 1.23e-15
 Заметьте, что в середине константы с плавающей точкой не может встречаться пробел. Например, 65.43 e-21 является не константой с плавающей точкой, а четырьмя отдельными лексическими символами (лексемами):
 65.43 e – 21
 и вызовет синтаксическую ошибку.
 Если вы хотите иметь константу константа с плавающей точкой; типа float, вы можете определить ее так (#2.4.6):
 const float pi = 3.14159265;




 2.4.3 Символьные Константы


 Хотя в С++ и нет отдельного символьного типа данных, точнее, символ может храниться в целом типе, в нем для символов имеется специальная и удобная запись. Символьная константа – это символ, заключенный в одинарные кавычки; например, 'a' или '0'. Такие символьные константы в действительности являются символическими константами для целого значения символов в наборе символов той машины, на которой будет выполняться программа (который не обязательно совпадает с набором символов, применяемом на том компьютере, где программа компилируется). Поэтому, если вы выполняетесь на машине, использующей набор символов ASCII, то значением '0' будет 48, но если ваша машина использует EBCDIC набор символов, то оно будет 240. Употребление символьных констант вместо десятичной записи делает программу более переносимой. Несколько символов также имеют стандартные имена, в которых обратная косая \ используется как escape-символ:
 '\b', возврат назад '\f', перевод формата '\n', новая строка '\r', возврат каретки '\t', горизонтальная табуляция '\v', вертикальная табуляция '\\', \ обратная косая (обратный слеш) '\'', одинарная кавычка ' '\"', двойная кавычка " '\0', null, пустой символ, целое значение 0
 Вопреки их внешнему виду каждое является одним символом. Можно также представлять символ одно-, два или трехзначным восьмеричным числом (символ \, за которым идут восьмеричные цифры), или одно-, два или трехзначным шестнадцатеричным числом (\x, за которым идут шестнадцатеричные цифры). Например:
 '\6' '\x6' 6 ASCII ack '\60' '\x30' 48 ASCII '0' '\137' '\x05f' 95 ASCII '_'
 Это позволяет представлять каждый символ из машинного набора символов, и в частности вставлять такие символы в символьные строки (см. следующий раздел). Применение числовой записи для символов делает программу непереносимой между машинами с различными наборами символов.




 2.4.4 Строки


 Строковая константа – это последовательность символов, заключенная в двойные кавычки "
 «это строка»
 Каждая строковая константа содержит на один символ больше, чем кажется; все они заканчиваются пустым символом '\0' со значением 0. Например:
 sizeof(«asdf»)==5;
 Строка имеет тип «вектор из соответствующего числа символов», поэтому «asdf» имеет тип char[5]. Пустая строка записывается "" (и имеет тип char[1]). Заметьте, что для каждой строки s strlen(s)==sizeof(s)-1, поскольку strlen() не учитывает завершающий 0.
 Соглашение о представлении неграфических символов с обратной косой можно использовать также и внутри строки. Это дает возможность представлять двойные кавычки и escape-символ. Самым обычным символом этого рода является, безусловно, символ новой строки '\n'. Например:
 cout «„ «гудок в конце сообщения\007\n“
 где 7 – значение ASKII символа bel (звонок).
 В строке невозможно иметь «настоящую» новую строку:
 «это не строка, а синтаксическая ошибка»
 Однако в строке может стоять обратная косая, сразу после которой идет новая строка; и то, и другое будет проигнорировано. Например:
 cout «„ «здесь все \ ok“
 напечатает
 здесь все ok
 Новая строка, перед которой идет escape (обратная косая), не приводит к появлению в строке новой строки, это просто договоренность о записи.
 В строке можно иметь пустой символ, но большинство программ не будет предполагать, что есть символы после него. Например, строка «asdf\000hjkl» будет рассматриваться стандартными функциями, вроде strcpy() и strlen(), как «asdf».
 Вставляя численную константу в строку с помощью восьмеричной или шестнадцатеричной записи благоразумно всегда использовать число из трех цифр. Читать запись достаточно трудно и без необходимости беспокоиться о том, является ли символ после константы цифрой или нет. Разберите эти примеры:
 char v1[] = «a\x0fah\0129»; // 'a' '\xfa' 'h' '\12' '9' char v2[] = «a\xfah\129»; // 'a' '\xfa' 'h' '\12' '9' char v3[] = «a\xfad\127»; // 'a' '\xfad' '\127'
 Имейте в виду, что двухзначной шестнадцатеричной записи на машинах с 9-битовым байтом будет недостаточно.




 2.4.5 Ноль


 Ноль можно употреблять как константу любого целого, плавающего или указательного типа. Никакой объект не размещается по адресу 0. Тип нуля определяется контекстом. Обычно (но не обязательно) он представляется набором битов все-нули соответствующей длины.




 2.4.6 Const


 Ключевое слово const может добавляться к описанию объекта, чтобы сделать этот объект константой, а не переменной. Например:
 const int model = 145; const int v[] = (* 1, 2, 3, 4 *);
 Поскольку константе ничего нельзя присвоить, она должна быть инициализирована. Описание чего-нибудь как const гарантирует, что его значение не изменится в области видимости:
 model = 145; // ошибка model++; // ошибка
 Заметьте, что const изменяет тип, то есть ограничивает способ использования объекта, вместо того, чтобы задавать способ размещения константы. Поэтому например вполне разумно, а иногда и полезно, описывать функцию как возвращающую const:
 const char* peek(int i) (* return private[i]; *)
 Функцию вроде этой можно было бы использовать для того, чтобы давать кому-нибудь читать строку, которая не может быть затерта или переписана (этим кем-то).
 С другой стороны, компилятор может несколькими путями воспользоваться тем, что объект является константой (конечно, в зависимости от того, насколько он сообразителен). Самое очевидное – это то, что для константы не требуется выделять память, поскольку компилятор знает ее значение. Кроме того, инициализатор константы часто (но не всегда) является константным выражением, то есть он может быть вычислен на стадии компиляции. Однако для вектора констант обычно приходится выделять память, поскольку компилятор в общем случае не может вычислить, на какие элементы вектора сделаны ссылки в выражениях. Однако на многих машинах даже в этом случае может достигаться повышение эффективности путем размещения векторов констант в память, доступную только для чтения.
 Использование указателя вовлекает два объекта: сам указатель и указываемый объект. Снабжение описания указателя «префиксом» const делает объект, но не сам указатель, константой. Например:
 const char* pc = «asdf»; // указатель на константу pc[3] = 'a'; // ошибка pc = «ghjk»; // ok
 Чтобы описать сам const указатель, а не указываемый объект, как константный, используется операция const*. Например:
 char *const cp = «asdf»; // константный указатель cp[3] = 'a'; // ok cp = «ghjk»; // ошибка
 Чтобы сделать константами оба объекта, их оба нужно описать const. Например:
 const char *const cpc = «asdf»; // const указатель на const cpc[3] = 'a'; // ошибка cpc = «ghjk»; // ошибка
 Объект, являющийся константой при доступе к нему через один указатель, может быть переменной, когда доступ осуществляется другими путями. Это в частности полезно для параметров функции. Посредством описания параметра указателя как const функции запрещается изменять объект, на который он указывает. Например:
 char* strcpy(char* p, const char* q); // не может изменить q
 Указателю на константу можно присваивать адрес переменой, поскольку никакого вреда от этого быть не может. Однако нельзя присвоить адрес константы указателю, на который не было наложено ограничение, поскольку это позволило бы изменить значение объекта. Например:
 int a = 1; const c = 2; const* p1 = amp;c; // ok const* p2 = amp;a; // ok int* p3 = amp;c; // ошибка *p3 = 7; // меняет значение c
 Как обычно, если тип в описании опущен, то он предполагается int.




 2.4.7 Перечисления


 Есть другой метод определения целых констант, который иногда более удобен, чем применение const. Например:
 enum (* ASM, AUTO, BREAK *);
 перечисление определяет три целых константы, называемых перечислителями, и присваивает им значения. Поскольку значения перечислителей по умолчанию присваиваются начиная с 0 в порядке возрастания, это эквивалентно записи:
 const ASM = 0; const AUTO = 1; const BREAK = 2;
 Перечисление может быть именованным. Например:
 enum keyword (* ASM, AUTO, BREAK *);
 Имя перечисления становится синонимом int, а не новым типом. Описание переменной keyword, а не просто int, может дать как программисту, так и компилятору подсказку о том, что использование преднамеренное. Например:
 keyword key;
 switch (key) (* case ASM: // что-то делает break; case BREAK: // что-то делает break; *)
 побуждает компилятор выдать предупреждение, поскольку только два значения keyword из трех используются.
 Можно также задавать значения перечислителей явно. Например:
 enum int16 (* sign=0100000, // знак most_significant=040000, // самый значимый least_significant=1 // наименее значимый *);
 Такие значения не обязательно должны быть различными, возрастающими или положительными.




 2.5 Экономия Пространства


 В ходе программирования нетривиальных разработок неизбежно наступает время, когда хочется иметь больше пространства памяти, чем имеется или отпущено. Есть два способа выжать побольше пространства из того, что доступно:
 1. Помещение в байт более одного небольшого объекта и
 2. Использование одного и того же пространства для хранения разных объектов в разное время.
 Первого можно достичь с помощью использования полей, второго – через использование объединений. Эти конструкции описываются в следующих разделах. Поскольку обычное их применение состоит чисто в оптимизации программы, и они в большинстве случаев непереносимы, программисту следует дважды подумать, прежде чем использовать их. Часто лучше изменить способ управления данными; например, больше полагаться на динамически выделяемую память (#3.2.6) и меньше на заранее выделенную статическую память.




 2.5.1 Поля


 Использование char для представления двоичной переменой, например, переключателя включено/выключено, может показаться экстравагантным, но char является наименьшим объектом, который в С++ может выделяться независимо. Можно, однако, сгруппировать несколько таких крошечных переменных вместе в виде полей struct. Член определяется как поле путем указания после его имени числа битов, которые он занимает. Допустимы неименованные поля; они не влияют на смысл именованных полей, но неким машинно-зависимым образом могут улучшить размещение:
 struct sreg (* unsigned enable : 1; unsigned page : 3; unsigned : 1; // неиспользуемое unsigned mode : 2; unsigned : 4: // неиспользуемое unsigned access : 1; unsigned length : 1; unsigned non_resident : 1; *)
 Получилось размещение регистра 0 состояния DEC PDP11/45 (в предположении, что поля в слове размещаются слева направо). Этот пример также иллюстрирует другое основное применение полей: именовать части внешне предписанного размещения. Поле должно быть целого типа и используется как другие целые, за исключением того, что невозможно взять адрес поля. В ядре операционной системы или в отладчике тип sreg можно было бы использовать так:
 sreg* sr0 = (sreg*)0777572; //... if (sr-»access) (* // нарушение доступа // чистит массив sr-»access = 0; *)
 Однако применение полей для упаковки нескольких переменных в один байт не обязательно экономит пространство. Оно экономит пространство, занимаемое данными, но объем кода, необходимого для манипуляции этими переменными, на большинстве машин возрастает. Известны программы, которые значительно сжимались, когда двоичные переменные преобразовывались из полей бит в символы! Кроме того, доступ к char или int обычно намного быстрее, чем доступ к полю. Поля – это просто удобная
 и краткая запись для применения логических операций с целью извлечения информации из части слова или введения информации в нее.




 2.5.2 Объединения


 Рассмотрим проектирование символьной таблицы, в которой каждый элемент содержит имя и значение, и значение может быть либо строкой, либо целым:
 struct entry (* char* name; char type; char* string_value; // используется если type == 's' int int_value; // используется если type == 'i' *);
 void print_entry(entry* p) (* switch p-»type (* case 's': cout «„ p-“string_value; break; case 'i': cout „„ p-“int_value; break; default: cerr «« «испорчен type\n“; break; *) *)
 Поскольку string_value и int_value никогда не могут использоваться одновременно, ясно, что пространство пропадает впустую. Это можно легко исправить, указав, что оба они должны быть членами union. Например, так:
 struct entry (* char* name; char type; union (* char* string_value; //используется если type == 's' int int_value; //используется если type == 'i' *); *);
 Это оставляет всю часть программы, использующую entry, без изменений, но обеспечивает, что при размещении entry string_value и int_value имеют один и тот же адрес. Отсюда следует, что все члены объединения вместе занимают лишь столько памяти, сколько занимает наибольший член.
 Использование объединений таким образом, чтобы при чтении значения всегда применялся тот член, с применением которого оно записывалось, совершенно оптимально. Но в больших программах непросто гарантировать, что объединения используются только таким образом, и из-за неправильного использования могут появляться трудно уловимые ошибки. Можно @капсулзировать объединение таким образом, чтобы соответствие между полем типа и типами членов было гарантированно правильным (#5.4.6).
 Объединения иногда используют для «объединения и преобразование типа» (это делают главным образом программисты, воспитанные на языках, не обладающих средствами преобразования типов, где жульничество является необходимым). Например, это «преобразует» на VAX'е int в int*, просто предполагая побитовую эквивалентность:
 struct fudge (* union (* int i; int* p; *); *);
 fudge a; a.i = 4096; int* p = a.p; // плохое использование
 Но на самом деле это совсем не преобразование: на некоторых машинах int и int* занимают неодинаковое количество памяти, а на других никакое целое не может иметь нечетный адрес. Такое применение объединений непереносимо, а есть явный способ указать преобразование типа (#3.2.5).
 Изредка объединения умышленно применяют, чтобы избежать преобразования типов. Можно, например, использовать fudge, чтобы узнать представление указателя 0:
 fudge.p = 0; int i = fudge.i; // i не обязательно должно быть 0
 Можно также дать объединению имя, то есть сделать его полноправным типом. Например, fudge можно было бы описать так:
 union fudge (* int i; int* p; *);
 и использовать (неправильно) в точности как раньше. Имеются также и оправданные применения именованных объединений, см. #5.4.6.




 2.6 Упражнения


 1. (*1) Заставьте работать программу с «Hello, world» (1.1.1).
 2. (*1) Для каждого описания в #2.1 сделайте следующее: Если описание не является определением, напишите для него определение. Если описание является определением, напишите для него описание, которое при этом не является определением.
 3. (*1) Напишите описания для: указателя на символ; вектора из 10 целых; ссылки на вектор из 10 целых; указателя на вектор из символьных строк; указателя на указатель на символ; константного целого; указателя на константное целое; и константного указателя на целое. Каждый из них инициализируйте.
 4. (*1.5) Напишите программу, которая печатает размеры основных и указательных типов. Используйте операцию sizeof.
 5. (*1.5) Напишите программу, которая печатает буквы 'a'...'z' и цифры '0'...'9' и их числовые значения. Сделайте то же для остальных печатаемых символов. Сделайте то же, но используя шестнадцатиричную запись.
 6. (*1) Напечатайте набор битов, которым представляется указатель 0 на вашей системе. Подсказка: #2.5.2.
 7. (*1.5) Напишите функцию, печатающую порядок и мантиссу параметра типа double.
 8. (*2) Каковы наибольшие и наименьшие значения, на вшей системе, следующих типов: char, short, int, long, float, double, unsigned, char*, int* и void*? Имеются ли дополнительные ограничения на принимаемые ими значения? Может ли, например, int* принимать нечетное значение? Как выравниваются в памяти объекты этих типов? Может ли, например, int иметь нечетный адрес?
 9. (*1) Какое самое длинное локальное имя можно использовать в С++ программе в вашей системе? Какое самое длинное внешнее имя можно использовать в С++ программе в вашей системе? Есть ли какие-нибудь ограничения на символы, которые моно употреблять в имени?
 10. (*2) Определите one следующим образом:
 const one = 1;
 Попытайтесь поменять значение one на 2. Определите num следующим образом:
 const num[] = (* 1, 2 *);
 Попытайтесь поменять значение num[1] на 2.
 11. (*1) Напишите функцию, переставляющую два целых (меняющую значения). Используйте в качестве типа параметра int*. Напишите другую переставляющую функцию, использующую в качестве типа параметра int amp;.
 12. (*1) Каков размер вектора str в следующем примере:
 char str[] = «a short string»;
 Какова длина строки «a short string»?
 13. (*1.5) Определите таблицу названий месяцев года и числа дней в них. Выведите ее. Сделайте это два раза: один раз используя вектор для названий и вектор для числа дней, и один раз используя вектор структур, в каждой из которых хранится название месяца и число дней в нем.
 14. (*1) С помощью typedef определите типы: беззнаковый char, константный беззнаковый char, указатель на целое, указатель на указатель на char, указатель на вектора символов, вектор из 7 целых указателей, указатель на вектор из 7 целых указателей, и вектор из 8 векторов из 7 целых указателей.




 Глава 3 Выражения и Операторы



 С другой стороны, мы не можем игнорировать эффективность

    Джон Бентли

 С++ имеет небольшой, но гибкий набор различных видов операторов для контроля потока управления в программе и богатый набор операций для манипуляции данными. С наиболее общепринятыми средствами вас познакомит один законченный пример. После него приводится резюмирующий обзор выражений и с довольно подробно описываются явное описание типа и работа со свободной памятью. Потом представлена краткая сводка операций, а в конце обсуждаются стиль выравнивания* и комментарии.
 – * Нам неизвестен русскоязычный термин, эквивалентный английскому indentation. Иногда это называется отступами. (прим. перев.)




 3.1 Настольный калькулятор


 С операторами и выражениями вас познакомит приведенная здесь программа настольного калькулятора, предоставляющего четыре стандартные арифметические операции над числами с плавающей точкой. Пользователь может также определять переменные. Например, если вводится
 r=2.5 area=pi*r*r
 (pi определено заранее), то программа калькулятора напишет:
 2.5 19.635
 где 2.5 – результат первой введенной строки, а 19.635 – результат второй.
 Калькулятор состоит из четырех основных частей: программы синтаксического разбора (parser'а), функции ввода, таблицы имен и управляющей программы (драйвера). Фактически, это миниатюрный компилятор, в котором программа синтаксического разбора производит синтаксический анализ, функция ввода осуществляет ввод и лексический анализ, в таблице имен хранится долговременная информация, а драйвер распоряжается инициализацией, выводом и обработкой ошибок. Можно было бы многое добавить в этот калькулятор, чтобы сделать его более полезным, но в существующем виде эта программа и так достаточно длинна (200 строк), и большая часть дополнительных возможностей просто увеличит текст программы не давая дополнительного понимания применения С++.




 3.1.1 Программа синтаксического разбора


 Вот грамматика языка, допускаемого калькулятором:
 program: END // END – это конец ввода expr_list END
 expr_list: expression PRINT // PRINT – это или '\n' или ';' expression PRINT expr_list
 expression: expression + term expression – term term
 term: term / primary term * primary primary
 primary: NUMBER // число с плавающей точкой в С++ NAME // имя С++ за исключением '_' NAME = expression – primary ( expression )
 Другими словами, программа есть последовательность строк. Каждая строка состоит из одного или более выражений, разделенных запятой. Основными элементами выражения являются числа, имена и операции *, /, +, – (унарный и бинарный) и =. Имена не обязательно должны описываться до использования.
 Используемый метод обычно называется рекурсивным спуском это популярный и простой нисходящий метод. В таком языке, как С++, в котором вызовы функций относительно дешевы, этот метод к тому же и эффективен. Для каждого правила вывода грамматики имеется функция, вызывающая другие функции. Терминальные символы (например, END, NUMBER, + и -) распознаются лексическим анализатором get_token(), а нетерминальные символы распознаются функциями синтаксического анализа expr(), term() и prim(). Как только оба операнда (под)выражения известны, оно вычисляется; в настоящем компиляторе в этой точке производится генерация кода.
 Программа разбора для получения ввода использует функцию get_token(). Значение последнего вызова get_token() находится в переменной curr_tok; curr_tok имеет одно из значений перечисления token_value:
 enum token_value (* NAME NUMBER END PLUS='+' MINUS='-' MUL='*' DIV='/' PRINT=';' ASSIGN='=' LP='(' RP=')' *); token_value curr_tok;
 В каждой функции разбора предполагается, что было обращение к get_token(), и в curr_tok находится очередной символ, подлежащий анализу. Это позволяет программе разбора заглядывать на один лексический символ (лексему) вперед и заставляет функцию разбора всегда читать на одну лексему больше, чем используется правилом, для обработки которого она была вызвана. Каждая функция разбора вычисляет «свое» выражение и возвращает значение. Функция expr() обрабатывает сложение и вычитание; она состоит из простого цикла, который ищет термы для сложения или вычитания:
 double expr() // складывает и вычитает (* double left = term();
 for(;;) // ``навсегда`` switch(curr_tok) (* case PLUS: get_token(); // ест '+' left += term();
 break; case MINUS: get_token(); // ест '-' left -= term(); break; default: return left; *) *)
 Фактически сама функция делает не очень много. В манере, достаточно типичной для функций более высокого уровня в больших программах, она вызывает для выполнения работы другие функции. Заметьте, что выражение 2-3+4 вычисляется как (2-3)+ 4, как указано грамматикой.
 Странная запись for(;;) – это стандартный способ задать бесконечный цикл. Можно произносить это как «навсегда»*. Это вырожденная форма оператора for, альтернатива – while(1). Выполнение оператора switch повторяется до тех пор, пока не будет найдено ни + ни -, и тогда выполняется оператор return в случае default.
 – * игра слов: «for» – «forever» (навсегда). (прим. перев.)
 Операции +=, -= используются для осуществления сложения и вычитания. Можно было бы не изменяя смысла программы использовать left=left+term() и left=left-term(). Однако left+= term() и left-=term() не только короче, но к тому же явно выражают подразумеваемое действие. Для бинарной операции @ выражение x@=y означает x=x@y за исключением того, что x вычисляется только один раз. Это применимо к бинарным операциям
 + – * / % amp; ! ^ «„ “»
 поэтому возможны следующие операции присваивания:
 += -= *= /= %= amp;= != ^= «„= “»=
 Каждая является отдельной лексемой, поэтому a+ =1 является синтаксической ошибкой из-за пробела между + и =. (% является операцией взятия по модулю; amp;,! и ^ являются побитвыми операциями И, ИЛИ и исключающее ИЛИ; «„ и “» являются операциями левого и правого сдвига). Функции term() и get_token() должны быть описаны до expr().
 Как организовать программу в виде набора файлов, обсудается в Главе 4. За одним исключением все описания в данной программе настольного калькулятора можно упорядочить так, чтобы все описывалось ровно один раз и до использования. Ислючением является expr(), которая обращается к term(), котрая обращается к prim(), которая в свою очередь обращается к expr(). Этот круг надо как-то разорвать;
 Описание
 double expr(); // без этого нельзя
 перед prim() прекрасно справляется с этим.
 Функция term() аналогичным образом обрабатывает умножние и сложение:
 double term() // умножает и складывает (* double left = prim();
 for(;;) switch(curr_tok) (* case MUL: get_token(); // ест '*' left *= prim(); break; case DIV: get_token(); // ест '/' double d = prim(); if (d == 0) return error(«деление на 0»); left /= d; break; default: return left; *) *)
 Проверка, которая делается, чтобы удостовериться в том, что нет деления на ноль, необходима, поскольку результат дления на ноль неопределен и как правило является роковым. Функция error(char*) будет описана позже. Переменная d ввдится в программе там, где она нужна, и сразу же инициализруется. Во многих языках описание может располагаться только в голове блока. Это ограничение может приводить к довольно скверному искажению стиля программирования и/или излишним ошибкам. Чаще всего неинициализированные локальные переменные являются просто признаком плохого стиля; исключением являются переменные, подлежащие инициализации посредством ввода, и пременные векторного или структурного типа, которые нельзя удобно инициализировать одними присваиваниями*. Заметьте, что = является операцией присваивания, а == операцией сравнения.
 – * В языке немного лучше этого с этими исключениями тоже надо бы справляться. (прим. автора)
 Функция prim, обрабатывающая primary, написана в осноном в том же духе, не считая того, что немного реальной рабты в ней все-таки выполняется, и нет нужды в цикле, поскольку мы попадаем на более низкий уровень иерархии вызовов:
 double prim() // обрабатывает primary (первичные) (* switch (curr_tok) (* case NUMBER: // константа с плавающей точкой get_token(); return number_value; case NAME: if (get_token() == ASSIGN) (* name* n = insert(name_string); get_token(); n-»value = expr(); return n-»value; *) return look(name-string)-»value; case MINUS: // унарный минус get_token(); return -prim(); case LP: get_token(); double e = expr(); if (curr_tok != RP) return error(«должна быть )»); get_token(); return e; case END: return 1; default:
 return error(«должно быть primary»); *) *)
 При обнаружении NUMBER (то есть, константы с плавающей точкой), возвращается его значение. Функция ввода get_token() помещает значение в глобальную переменную number_value. Ипользование в программе глобальных переменных часто указывает на то, что структура не совсем прозрачна, что применялась нкоторого рода оптимизация. Здесь дело обстоит именно так. Торетически лексический символ обычно состоит из двух частей: значения, определяющего вид лексемы (в данной программе token _value), и (если необходимо) значения лексемы. У нас имеется только одна простая переменная curr_tok, поэтому для хранения значения последнего считанного NUMBER понадобилась глобальная переменная переменная number_value. Это работает только потму, что калькулятор при вычислениях использует только одно число перед чтением со входа другого.
 Так же, как значение последнего встреченного NUMBER хранится в number_value, в name_string в виде символьной строки хранится представление последнего прочитанного NAME. Перед тем, как что-либо сделать с именем, калькулятор должен заглнуть вперед, чтобы посмотреть, осуществляется ли присваивание ему, или оно просто используется. В обоих случаях надо спрвиться в таблице имен. Сама таблица описывается в #3.1.3; здесь надо знать только, что она состоит из элементов вида:
 srtuct name (* char* string; char* next; double value; *)
 где next используется только функциями, которые поддерживают работу с таблицей:
 name* look(char*); name* insert(char*);
 Обе возвращают указатель на name, соответствующее парметру – символьной строке; look() выражает недовольство, если имя не было определено. Это значит, что в калькуляторе можно использовать имя без предварительного описания, но первый раз оно должно использоваться в левой части присваивания.




 3.1.2 Функция ввода


 Чтение ввода – часто самая запутанная часть программы. Причина в том, что если программа должна общаться с человком, то она должна справляться с его причудами, условностями и внешне случайными ошибками. Попытки заставить человека вети себя более удобным для машины образом часто (и справедлво) рассматриваются как оскорбительные. Задача низкоуровневой программы ввода состоит в том, чтобы читать символы по одному и составлять из них лексические символы более высокого уроня. Далее эти лексемы служат вводом для программ более выского уровня. У нас ввод низкого уровня осуществляется get_token(). Обнадеживает то, что написание программ ввода низкого уровня не является ежедневной работой; в хорошей ситеме для этого будут стандартные функции.
 Для калькулятора правила сознательно были выбраны такми, чтобы функциям по работе с потоками было неудобно эти правила обрабатывать; незначительные изменения в определении лексем сделали бы get_token() обманчиво простой. Первая сложность состоит в том, что символ новой строки
 '\n' является для калькулятора существенным, а функции работы с потоками считают его символом пропуска. То есть, для этих функций '\n' значим только как ограничитель лексемы. Чтобы преодолеть это, надо проверять пропуски (пробел, символы тбуляции и т.п.):
 char ch
 do (* // пропускает пропуски за исключением '\n' if(!cin.get(ch)) return curr_tok = END; *) while (ch!='\n' amp; amp; isspace(ch));
 Вызов cin.get(ch) считывает один символ из стандартного потока ввода в ch. Проверка if(!cin.get(ch)) не проходит в случае, если из cin нельзя считать ни одного символа. В этом случае возвращается END, чтобы завершить сеанс работы кальклятора. Используется операция ! (НЕ), поскольку get() возврщает в случае успеха ненулевое значение.
 Функция (inline) isspace() из «ctype.h» обеспечивает стандартную проверку на то, является ли символ пропуском (#8.4.1); isspace(c) возвращает ненулевое значение, если c является символом пропуска, и ноль в противном случае. Прверка реализуется в виде поиска в таблице, поэтому использвание isspace() намного быстрее, чем проверка на отдельные символы пропуска; это же относится и к функциям isalpha(), isdigit() и isalnum(), которые используются в get_token().
 После того, как пустое место пропущено, следующий символ используется для определения того, какого вида какого вида лексема приходит. Давайте сначала рассмотрим некоторые случаи отдельно, прежде чем приводить всю функцию. Ограничители лесем '\n' и ';' обрабатываются так:
 switch (ch) (* case ';': case '\n': cin »» WS; // пропустить пропуск return curr_tok=PRINT;
 Пропуск пустого места делать необязательно, но он позвляет избежать повторных обращений к get_token(). WS – это стандартный пропусковый объект, описанный в «stream.h»; он используется только для сброса пропуска. Ошибка во вводе или конец ввода не будут обнаружены до следующего обращения к get _token(). Обратите внимание на то, как можно использовать несколько меток case (случаев) для одной и той же последовтельности операторов, обрабатывающих эти случаи. В обоих случаях возвращается лексема PRINT и помещается в curr_tok.
 Числа обрабатываются так:
 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.': cin.putback(ch); cin »» number_value; return curr_tok=NUMBER;
 Располагать метки случаев case горизонтально, а не ветикально, не очень хорошая мысль, поскольку читать это гораздо труднее, но отводить по одной строке на каждую цифру нудно.
 Поскольку операция »» определена также и для чтения констант с плавающей точкой в double, программирование этого не составляет труда: сперва начальный символ (цифра или точка) помещается обратно в cin, а затем можно считывать контанту в number_value.
 Имя, то есть лексема NAME, определяется как буква, за которой возможно следует несколько букв или цифр:
 if (isalpha(ch)) (* char* p = name_string; *p++ = ch; while (cin.get(ch) amp; amp; isalnum(ch)) *p++ = ch; cin.putback(ch); *p = 0; return curr_tok=NAME; *)
 Эта часть строит в name_string строку, заканчивающуюся нулем. Функции isalpha() и isalnum() заданы в «ctype.h»; isalnum(c) не ноль, если c буква или цифра, ноль в противном случае.
 Вот, наконец, функция ввода полностью:
 token_value get_token() (* char ch;
 do (* // пропускает пропуски за исключением '\n' if(!cin.get(ch)) return curr_tok = END; *) while (ch!='\n' amp; amp; isspace(ch));
 switch (ch) (* case ';': case '\n': cin »» WS; // пропустить пропуск return curr_tok=PRINT; case '*': case '/': case '+': case '-': case '(': case ')': case '=': return curr_tok=ch; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.': cin.putback(ch); cin »» number_value; return curr_tok=NUMBER; default: // NAME, NAME= или ошибка if (isalpha(ch)) (* char* p = name_string; *p++ = ch; while (cin.get(ch) amp; amp; isalnum(ch)) *p++ = ch; cin.putback(ch); *p = 0; return curr_tok=NAME; *) error(«плохая лексема»); return curr_tok=PRINT; *) *)
 Поскольку token_value (значение лексемы) операции было определено как целое значение этой операции*, обработка всех операций тривиальна.
 – * знака этой операции. (прим. перев.)




 3.1.3 Таблица имен


 К таблице имен доступ осуществляется с помощью одной функции
 name* look(char* p, int ins =0);
 Ее второй параметр указывает, нужно ли сначала поместить строку символов в таблицу. Инициализатор =0 задает параметр, который надлежит использовать по умолчанию, когда look() взывается с одним параметром. Это дает удобство записи, когда look(«sqrt2») означает look(«sqrt2»,0), то есть просмотр, без помещения в таблицу. Чтобы получить такое же удобство записи для помещения в таблицу, определяется вторая функция:
 inline name* insert(char* s) (* return look(s,1);*)
 Как уже отмечалось раньше, элементы этой таблицы имеют тип:
 srtuct name (* char* string; char* next; double value; *)
 Член next используется только для сцепления вместе имен в таблице.
 Сама таблица – это просто вектор указателей на объекты типа name:
 const TBLSZ = 23; name* table[TBLSZ];
 Поскольку все статические объекты инициализируются нлем, это тривиальное описание таблицы table гарантирует также надлежащую инициализацию.
 Для нахождения элемента в таблице в look() принимается простой алгоритм хэширования (имена с одним и тем же хэш-кдом зацепляются вместе):
 int ii = 0; // хэширование char* pp = p; while (*pp) ii = ii««1 ^ *pp++; if (ii « 0) ii = -ii; ii %= TBLSZ;
 То есть, с помощью исключающего ИЛИ каждый символ во входной строке «добавляется» к ii («сумме» предыдущих символов). Бит в x^y устанавливается единичным тогда и только тода, когда соответствующие биты в x и y различны. Перед примнением в символе исключающего ИЛИ, ii сдвигается на один бит влево, чтобы не использовать в слове только один байт. Это можно было написать и так:
 ii ««= 1; ii ^= *pp++;
 Кстати, применение ^ лучше и быстрее, чем +. Сдвиг важен для получения приемлемого хэш-кода в обоих случаях. Операторы
 if (ii « 0) ii = -ii; ii %= TBLSZ;
 обеспечивают, что ii будет лежать в диапазоне 0...TBLS1; % – это операция взятия по модулю (еще называемая получнием остатка).
 Вот функция полностью:
 extern int strlen(const char*); extern int strcmp(const char*, const char*); extern int strcpy(const char*, const char*);
 name* look(char* p, int ins =0) (* int ii = 0; // хэширование char* pp = p; while (*pp) ii = ii««1 ^ *pp++; if (ii « 0) ii = -ii; ii %= TBLSZ;
 for (name* n=table[ii]; n; n=n-»next) // поиск if (strcmp(p,n-»string) == 0) return n;
 if (ins == 0) error(«имя не найдено»);
 name* nn = new name; // вставка nn-»string = new char[strlen(p)+1]; strcpy(nn-»string,p); nn-»value = 1; nn-»next = table[ii]; table[ii] = nn; return nn; *)
 После вычисления хэш-кода ii имя находится простым промотром через поля next. Проверка каждого name осуществляется с помощью стандартной функции strcmp(). Если строка найдена, возвращается ее name, иначе добавляется новое name.
 Добавление нового name включает в себя создание нового объекта в свободной памяти с помощью операции new (см. #3.2.6), его инициализацию, и добавление его к списку имен. Последнее осуществляется просто путем помещения нового имени в голову списка, поскольку это можно делать даже не проверяя, имеется список, или нет. Символьную строку для имени тоже нужно сохранить в свободной памяти. Функция strlen() исползуется для определения того, сколько памяти нужно, new – для выделения этой памяти, и strcpy() – для копирования строки в память.




 3.1.4 Обработка ошибок


 Поскольку программа так проста, обработка ошибок не сотавляет большого труда. Функция обработки ошибок просто счтает ошибки, пишет сообщение об ошибке и возвращает управлние обратно:
 int no_of_errors;
 double error(char* s) (* cerr «„ "error: " «« s «« «\n“; no_of_errors++; return 1; *)
 Возвращается значение потому, что ошибки обычно встречаются в середине вычисления выражения, и поэтому надо либо полностью прекращать вычисление, либо возвращать значение, которое по всей видимости не должно вызвать последующих ошибок. Для простого калькулятора больше подходит последнее. Если бы get_token() отслеживала номера строк, то error() мола бы сообщать пользователю, где приблизительно обнаружена ошибка. Это наверняка было бы полезно, если бы калькулятор использовался неитерактивно.
 Часто бывает так, что после появления ошибки программа должна завершиться, поскольку нет никакого разумного пути продолжить работу. Это можно сделать с помощью вызова exit(), которая очищает все вроде потоков вывода (#8.3.2), а затем завершает программу используя свой параметр в качестве ее возвращаемого значения. Более радикальный способ завершения программы – это вызов abort(), которая обрывает выполнение сразу же или сразу после сохранения где-то информации для оладчика (дамп памяти); о подробностях справьтесь, пожалуйста, в вашем руководстве.




 3.1.5 Драйвер


 Когда все части программы на месте, нам нужен только драйвер для инициализации и всего того, что связано с запуком. В этом простом примере main() может работать так:
 int main() (* // вставить предопределенные имена: insert(«pi»)-»value = 3.1415926535897932385; insert("e")-»value = 2.7182818284590452354;
 while (cin) (* get_token(); if (curr_tok == END) break; if (curr_tok == PRINT) continue; cout «„ expr() «« «\n“; *) return no_of_errors; *)
 Принято обычно, что main() возвращает ноль при нормалном завершении программы и не ноль в противном случае, поэтому это прекрасно может сделать возвращение числа ошибок. В данном случае оказывается, что инициализация нужна только для введения предопределенных имен в таблицу имен.
 Основная работа цикла – читать выражения и писать ответ. Это делает строка:
 cout «„ expr() «« «\n“;
 Проверка cin на каждом проходе цикла обеспечивает завешение программы в случае, если с потоком ввода что-то не так, а проверка на END обеспечивает корректный выход из цикла, когда get_token() встречает конец файла. Оператор break осуществляет выход из ближайшего содержащего его оператора switch или оператора цикла (то есть, оператора for, оператора while или оператора do). Проверка на PRINT (то есть, на '\n' или ';') освобождает expr() от обязанности обрабатывать путые выражения. Оператор continue равносилен переходу к самому концу цикла, поэтому в данном случае
 while (cin) (* // ... if (curr_tok == PRINT) continue; cout «„ expr() «« «\n“; *)
 эквивалентно
 while (cin) (* // ... if (curr_tok == PRINT) goto end_of_loop; cout «„ expr() «« «\n“; end_of_loop *)
 Более подробно циклы описываются в #с.9.




 3.1.6 Параметры командной строки


 После того, как программа была написана и оттестирована, я заметил, что часто набирать выражения на клавиатуре в стадартный ввод надоедает, поскольку обычно использование прораммы состоит в вычислении одного выражения. Если бы можно было представлять это выражение как параметр командной стрки, не приходилось бы так много нажимать на клавиши.
 Как уже говорилось, программа запускается вызовом main(). Когда это происходит, main() получает два параметра указывающий число параметров, обычно называемый argc и вектор параметров, обычно называемый argv. Параметры – это символные строки, поэтому argv имеет тип char*[argc]. Имя программы (так, как оно стоит в командной строке) передается в качестве argv[0], поэтому argc всегда не меньше единицы. Например, в случае команды
 dc 150/1.1934
 параметры имеют значения:
 argc 2 argv[0] «dc» argv[1] «150/1.1934»
 Научиться пользоваться параметрами командной строки неложно. Сложность состоит в том, как использовать их без препрограммирования. В данном случае это оказывается совсем просто, поскольку поток ввода можно связать с символьной строкой, а не с файлом (#8.5). Например, можно заставить cin читать символы из стандартного ввода:
 int main(int argc, char* argv[]) (* switch(argc) (* case 1: // читать из стандартного ввода break; case 2: // читать параметр строку cin = *new istream(strlen(argv[1]),argv[1]); break; default: error(«слишком много параметров»); return 1; *) // как раньше *)
 Программа осталась без изменений, за исключением добаления в main() параметров и использования этих параметров в
 операторе switch. Можно было бы легко модифицировать main() так, чтобы она получала несколько параметров командной стрки, но это оказывается ненужным, особенно потому, что неколько выражений можно передавать как один параметр: dc «rate=1.1934;150/rate;19.75/rate;217/rate»
 Здесь кавычки необходимы, поскольку ; является разделтелем команд в системе UNIX.




 3.2 Краткая сводка операций


 Операции С++ подробно и систематически описываются в #с. 7; прочитайте, пожалуйста, этот раздел. Здесь же приводится операция краткая сводка и некоторые примеры. После каждой операции приведено одно или более ее общеупотребительных наваний и пример ее использования. В этих примерах имя_класса – это имя класса, член – имя члена, объект – выражение, дающее в результате объект класса, указатель – выражение, дающее в результате указатель, выр – выражение, а lvalue – выражение, денотирующее неконстантный объект. Тип может быть совершенно произвольным именем типа (со * () и т.п.) только когда он стоит в скобках, во всех остальных случаях существуют огранчения.
 Унарные операции и операции присваивания правоассоцитивны, все остальные левоассоциативны. Это значит, что a=b=c означает a=(b=c), a+b+c означает (a+b)+c, и *p++ означает *(p ++), а не (*p)++.
 Сводка Операций (часть 1) =========================================================== :: разрешение области видимости имя_класса :: член :: глобальное :: имя =========================================================== -» выбор члена указатель-»член [] индексация указатель [ выр ] () вызов функции выр (список_выр) () построение значения тип (список_выр) sizeof размер объекта sizeof выр sizeof размер типа sizeof ( тип ) =========================================================== ++ приращение после lvalue++ ++ приращение до ++lvalue – уменьшение после lvalue– – уменьшение до –lvalue ~ дополнение ~ выр ! не ! выр – унарный минус – выр + унарный плюс + выр amp; адрес объекта amp; lvalue * разыменование * выр new создание (размещение) new тип delete уничтожение (освобождение) delete указатель delete[] уничтожение вектора delete[ выр ] указатель () приведение (преобразование типа) ( тип ) выр =========================================================== * умножение выр * выр / деление выр / выр % взятие по модулю (остаток) выр % выр =========================================================== + сложение (плюс) выр + выр – вычитание (минус) выр – выр =========================================================== «„ сдвиг влево lvalue „„ выр ““ сдвиг вправо lvalue “» выр =========================================================== « меньше выр « выр
 «= меньше или равно выр „= выр “ больше выр » выр »= больше или равно выр »= выр =========================================================== == равно выр == выр != не равно выр != выр =========================================================== amp; побитовое И выр amp; выр =========================================================== ^ побитовое исключающее ИЛИ выр ^ выр =========================================================== ! побитовое включающее ИЛИ выр ! выр =========================================================== amp; amp; логическое И выр amp; amp; выр =========================================================== !! логическое включающее ИЛИ выр !! выр =========================================================== ? : арифметический if выр ? выр : выр =========================================================== = простое присваивание lvalue = выр *= умножить и присвоить lvalue = выр /= разделить и присвоить lvalue /= выр %= взять по модулю и присвоить lvalue %= выр += сложить и присвоить lvalue += выр -= вычесть и присвоить lvalue -= выр «„= сдвинуть влево и присвоить lvalue „„= выр ““= сдвинуть вправо и присвоить lvalue “»= выр amp;= И и присвоить lvalue amp;= выр != включающее ИЛИ и присвоить lvalue != выр ^= исключающее ИЛИ и присвоить lvalue ^= выр =========================================================== , запятая (следование) выр , выр ===========================================================
 В каждой очерченной части находятся операции с одинаквым приоритетом. Операция имеет приоритет больше, чем оперции из частей, расположенных ниже. Например: a+b*c означает a +(b*c), так как * имеет приоритет выше, чем +, а a+b-c ознчает (a+b)-c, поскольку + и – имеют одинаковый приоритет (и поскольку + левоассоциативен).




 3.2.1 Круглые скобки


 Скобками синтаксис С++ злоупотребляет; количество спосбов их использования приводит в замешательство: они применются для заключения в них параметров в вызовах функций, в них заключается тип в преобразовании типа (приведении к типу), в именах типов для обозначения функций, а также для разрешения конфликтов приоритетов. К счастью, последнее требуется не слишком часто, потому что уровни приоритета и правила ассоцативности определены таким образом, чтобы выражения «работали ожидаемым образом» (то есть, отражали наиболее привычный спсоб употребления). Например, значение
 if (i«=0 !! max«i) // ...
 очевидно. Тем не менее, всегда, когда программист сомнвается относительно этих правил, следует употреблять скобки, и некоторые программисты предпочитают немного более длинное и менее элегантное
 if ( (i«=0) !! (max«i) ) // ...
 При усложнении подвыражений употребление скобок станвится более обычным явлением, но сложные подвыражения являюся источником ошибок, поэтому если вы чувствуете потребность в скобках, попробуйте оборвать выражение и использовать дополнительную переменную. Есть и такие случаи, когда приоритты операций не приводят к «очевидному» результату. Например в
 if (i amp;mask == 0) // ...
 не происходит применения маски mask к i и последующей проверки результата на ноль. Поскольку == имеет приоритет вше, чем amp;, выражение интерпретируется как i amp;(mask==0). В этом случае скобки оказываются важны:
 if ((i amp;mask) == 0) // ...
 Но, с другой стороны, то, что следующее выражение не рботает так, как может ожидать наивный пользователь, ничего не значит:
 if (0 «= a «= 99) // ...
 Оно допустимо, но интерпретируется оно как (0«=a)«=99, где результат первого подвыражения или 0 или 1, но не a (если только a не равно 1). Чтобы проверить, лежит ли a в диапазоне 0...99, можно написать
 if (0«=a amp; amp; a«=99) // ...




 3.2.2 Порядок вычисления


 Порядок вычисления подвыражений в выражении неопределен. Например
 int i = 1; v[i] = i++;
 может вычисляться или как v[1]=1, или как v[2]=1. При отсутствии ограничений на порядок вычисления выражения может генерироваться более хороший код. Было бы замечательно, если бы компилятор предупреждал о подобных неоднозначностях, но большинство компиляторов этого не делают.
 Относительно операций amp; amp; и !! гарантируется, что их левый операнд вычисляется раньше, чем правый. Например, b=(a=2,a=1) присвоит b 3.В #3.3.1приводятся примеры использования amp; amp; и !!. Заметьте, что операция следования , (запятая) логически отличается от запятой, которая используется для разделения параметров в вызове функции. Рассмотрим
 f1(v[i],i++); // два параметра f2( (v[i],i++) ) // один параметр
 В вызове f1 два параметра, v[i] и i++, и порядок вычиления выражений-параметров неопределен. Зависимость выражения -параметра от порядка вычисления – это очень плохой стиль, а также непереносимо. В вызове f2 один параметр, выражение с запятой, которое эквивалентно i++.
 С помощью скобок нельзя задать порядок вычисления. Например, a*(b/c) может вычисляться и как (a*b)/c, поскольку * и / имеют одинаковый приоритет. В тех случаях, когда важен прядок вычисления, можно вводить дополнительную переменную, например, (t=b/c,a*t).




 3.2.3 Увеличение и уменьшение*


 – * Следовало бы переводить как «инкремент» и «декремент», однако мы следовали терминологии, принятой в переводной литратуре по C, поскольку эти операции унаследованы от C. (прим.
 перев.)
 Операция ++ используется для явного выражения приращения вместо его неявного выражения с помощью комбинации сложения и присваивания. По определению ++lvalue означает lvalue+=1, что в свою очередь означает lvalue=lvalue+1 при условии, что lvalue не вызывает никаких побочных эффектов. Выражение, обозначающее (денотирующее) объект, который должен быть увличен, вычисляется один раз (только). Аналогично, уменьшение выражается операцией –. Операции ++ и – могут применяться и как префиксные, и как постфиксные. Значением ++x является нвое (то есть увеличенное) значение x. Например, y=++x эквивлентно y=(x+=1). Значение x++, напротив, есть старое значение x. Например, y=x++ эквивалентно y=(t=x,x+=1,t), где t – перменная того же типа, что и x.
 Операции приращения особенно полезны для увеличения и уменьшения переменных в циклах. Например, оканчивающуюся нлем строку можно копировать так:
 inline void cpy(char* p, const char* q) (* while (*p++ = *q++) ; *)
 Напомню, что увеличение и уменьшение арифметических указателей, так же как сложение и вычитание указателей, осуществляется в терминах элементов вектора, на которые указывает указатель p++ приводит к тому, что p указывает на следующий элемент. Для указателя p типа T* по определению выполняется следующее:
 long(p+1) == long(p)+sizeof(T);




 3.2.4 Побитовые логические операции


 Побитовые логические операции
 amp; ! ^ ~ »» ««
 применяются к целым, то есть к объектам типа char, short, int, long и их unsigned аналогам, результаты тоже цлые.
 Одно из стандартных применений побитовых логических опраций – реализация маленького множества (вектор битов). В этом случае каждый бит беззнакового целого представляет один член множества, а число членов ограничено числом битов. Бнарная операция amp; интерпретируется как пересечение, ! как объединение, а ^ как разность. Для наименования членов такого множества можно использовать перечисление. Вот маленький прмер, заимствованный из реализации (не пользовательского итерфейса) «stream.h»:
 enum state_value (* _good=0, _eof=1, _fail=2, _bad=4 *); // хорошо, конец файла, ошибка, плохо
 Определение _good не является необходимым. Я просто хтел, чтобы состояние, когда все в порядке, имело подходящее имя. Состояние потока можно установить заново следующим обрзом:
 cout.state = _good;
 Например, так можно проверить, не был ли испорчен поток или допущена операционная ошибка:
 if (cout.state amp;(_bad!_fail)) // не good
 Еще одни скобки необходимы, поскольку amp; имеет более всокий приоритет, чем !.
 Функция, достигающая конца ввода, может сообщать об этом так:
 cin.state != _eof;
 Операция != используется потому, что поток уже может быть испорчен (то есть, state==_bad), поэтому
 cin.state = _eof;
 очистило бы этот признак. Различие двух потоков можно находить так:
 state_value diff = cin.state^cout.state;
 В случае типа stream_state (состояние потока) такая раность не очень нужна, но для других похожих типов она оказвается самой полезной. Например, при сравнении вектора бит, представляющего множество прерываний, которые обрабатываются, с другим, представляющим прерывания, ждущие обработки.
 Следует заметить, что использование полей (#2.5.1) в действительности является сокращенной записью сдвига и маскрования для извлечения полей бит из слова. Это, конечно, моно сделать и с помощью побитовых логических операций, Например, извлечь средние 16 бит из 32-битового int можно следующим образом:
 unsigned short middle(int a) (* return (a»»8) amp;0xffff; *)
 Не путайте побитовые логические операции с логическими операциями:
 amp; amp; !! !
 Последние возвращают 0 или 1, и они главным образом ипользуются для записи проверки в операторах if, while или for (#3.3.1). Например, !0 (не ноль) есть значение 1, тогда как ~ 0 (дополнение нуля) есть набор битов все-единицы, который обычно является значением -1.




 3.2.5 Преобразование типа


 Бывает необходимо явно преобразовать значение одного тпа в значение другого. Явное преобразование типа дает значние одного типа для данного значения другого типа. Например:
 float r = float(1);
 перед присваиванием преобразует целое значение 1 к знчению с плавающей точкой 1.0. Результат преобразования типа не является lvalue, поэтому ему нельзя присваивать (если только тип не является ссылочным типом).
 Есть два способа записи явного преобразования типа: трдиционная в C запись приведения к типу (double)a и функцинальная запись double(a). Функциональная запись не может прменяться для типов, которые не имеют простого имени. Например, чтобы преобразовать значение к указательному типу надо или использовать запись преобразования типа
 char* p = (char*)0777;
 или определить новое имя типа:
 typedef char* Pchar; char* p = Pchar(0777);
 По моему мнению, функциональная запись в нетривиальных случаях предпочтительна. Рассмотрим два эквивалентных примера
 Pname n2 = Pbase(n1-»tp)-»b_name; //функциональная запись Pname n3 = ((Pbase)n2-»tp)-»b_name; // запись приведения // к типу Поскольку операция -» имеет больший приоритет, чем прведение, последнее выражение интерпретируется как
 ((Pbase)(n2-»tp))-»b_name
 С помощью явного преобразования типа к указательным тпам можно симитировать, что объект имеет совершенно проивольный тип. Например:
 any_type* p = (any_type*) amp;some_object;
 позволит работать посредством p с некоторым объектом some_object как с любым типом any_type.
 Когда преобразование типа не необходимо, его следует ибегать. Программы, в которых используется много явных преоразований типов, труднее понимать, чем те, в которых это не делается. Однако такие программы легче понимать, чем программы, просто не использующие типы для представления понятий блее высокого уровня (например, программу, которая оперирует регистром устройства с помощью сдвига и маскирования, вместо того, чтобы определить подходящую struct и оперировать ею, см. #2.5.2). Кроме того, правильность явного преобразования типа часто критическим образом зависит от понимания програмистом того, каким образом объекты различных типов обрабатваются в языке, и очень часто от подробностей реализации. Например:
 int i = 1; char* pc = «asdf»; int* pi = amp;i;
 i = (int)pc; pc = (char*)i; // остерегайтесь! значение pc может изм//ниться // на некоторых машинах // sizeof(int)«sizeof(char*) pi = (int*)pc; pc = (char*)pi; // остерегайтесь! значение pc может изм// ниться // на некоторых машинах char* // представляется иначе, чем int*
 На многих машинах ничего плохого не произойдет, но на других результаты будут катастрофическими. Этот код в лучшем случае непереносим. Обычно можно без риска предполагать, что указатели на различные структуры имеют одинаковое представлние. Кроме того, любой указатель можно (без явного преобразвания типа) присвоить void*, а void* можно явно преобразовать к указателю любого типа.
 В С++ явное преобразование типа оказывается ненужным во многих случаях, когда C (и другие языки) требуют его. Во мнгих программах явного преобразования типа можно совсем избжать, а во многих других его применение можно локализовать в
 небольшом числе подпрограмм.
  3.2.6 Свободная память  
 Именованный объект является либо статическим, либо автоматическим (см. #2.1.3). Статический объект размещается во время запуска программы и существует в течение всего выполнния программы. Автоматический объект размещается каждый раз при входе в его блок и существует только до тех пор, пока из этого блока не вышли. Однако часто бывает полезно создать нвый объект, существующий до тех пор, пока он не станет больше не нужен. В частности, часто полезно создать объект, который можно использовать после возврата из функции, где он создаеся. Такие объекты создает операция new, а впоследствии унитожать их можно операцией delete. Про объекты, выделенные с помощью операции new, говорят, что они в свободной памяти. Такими объектами обычно являются вершины деревьев или элеметы связанных списков, являющиеся частью большей структуры данных, размер которой не может быть известен на стадии копиляции. Рассмотрим, как можно было бы написать компилятор в духе написанного настольного калькулятора. Функции синтаксческого анализа могут строить древовидное представление выржений, которое будет использоваться при генерации кода. Например:
 struct enode (* token_value oper; enode* left; enode* right; *);
 enode* expr() (* enode* left = term();
 for(;;) switch(curr_tok) (* case PLUS: case MINUS: get_token(); enode* n = new enode; n-»oper = curr_tok; n-»left = left; n-»right = term(); left = n; break; default: return left; *) *)
 Получающееся дерево генератор кода может использовать например так:
 void generate(enode* n) (* switch (n-»oper) (* case PLUS: // делает нечто соответствующее delete n; *) *)
 Объект, созданный с помощью new, существует, пока он не будет явно уничтожен delete, после чего пространство, которое он занимал, опять может использоваться new. Никакого «сборщка мусора», который ищет объекты, на которые нет ссылок, и предоставляет их в распоряжение new, нет. Операция delete может применяться только к указателю, который был возвращен операцией new, или к нулю. Применение delete к нулю не вызвает никаких действий.
 С помощью new можно также создавать вектора объектов. Например:
 char* save_string(char* p) (* char* s = new char[strlen(p)+1]; strcpy(s,p); return s; *)
 Следует заметить, что чтобы освободить пространство, вделенное new, delete должна иметь возможность определить размер выделенного объекта. Например:
 int main(int argc, char* argv[]) (* if (argc « 2) exit(1); char* p = save_string(argv[1]); delete p; *)
 Это приводит к тому, что объект, выделенный стандартной реализацией new, будет занимать больше места, чем статический объект (обычно, больше на одно слово).
 Можно также явно указывать размер вектора в операции уничтожения delete. Например:
 int main(int argc, char* argv[]) (* if (argc « 2) exit(1); int size = strlen(argv[1])+1; char* p = save_string(argv[1]); delete[size] p; *)
 Заданный пользователем размер вектора игнорируется за исключением некоторых типов, определяемых пользователем (#5.5.5).
 Операции свободной памяти реализуются функциями (#с.7.2.3):
 void operator new(long); void operator delete(void*);
 Стандартная реализация new не инициализирует возвращамый объект.
 Что происходит, когда new не находит памяти для выделния? Поскольку даже виртуальная память конечна, это иногда должно происходить. Запрос вроде
 char* p = new char[100000000];
 как правило, приводит к каким-то неприятностям. Когда у new ничего не получается, она вызывает функцию, указываемую указателем _new_handler (указатели на функции обсуждаются в # 4.6.9). Вы можете задать указатель явно или использовать функцию set_new_handler(). Например:
 #include «stream.h»
 void out_of_store()
 (* cerr «„ «операция new не прошла: за пределами памяти\n“; exit(1); *)
 typedef void (*PF)(); // тип указатель на функцию
 extern PF set_new_handler(PF);
 main() (* set_new_handler(out_of_store); char* p = new char[100000000]; cout «„ "сделано, p = " «« long(p) «« «\n“; *)
 как правило, не будет писать «сделано», а будет вместо этого выдавать
 операция new не прошла: за пределами памяти
 Функция _new_handler может делать и кое-что поумней, чем просто завершать выполнение программы. Если вы знаете, как работают new и delete, например, потому, что вы задали свои собственные operator new() и operator delete(), программа оработки может попытаться найти некоторое количество памяти, которое возвратит new. Другими словами, пользователь может сделать сборщик мусора, сделав, таким образом, использование delete необязательным. Но это, конечно, все-таки задача не для начинающего.
 По историческим причинам new просто возвращает указатель 0, если она не может найти достаточное количество памяти и не был задан никакой _new_handler. Например
 include «stream.h»
 main() (* char* p = new char[100000000]; cout «„ "сделано, p = " «« long(p) «« «\n“; *)
 выдаст
 сделано, p = 0
 Вам сделали предупреждение! Заметьте, что тот, кто задет _new_handler, берет на себя заботу по проверке истощения памяти при каждом использовании new в программе (за исключнием случая, когда пользователь задал отдельные подпрограммы для размещения объектов заданных типов, определяемых пользвателем, см. #5.5.6).




 3.3 Сводка операторов


 Операторы С++ систематически и полностью изложены в #с.9, прочитайте, пожалуйста, этот раздел. А здесь приводится краткая сводка и некоторые примеры.
 Синтаксис оператора – оператор: описание (*список_операторов opt*) выражение opt
 if оператор if ( выражение ) оператор if ( выражение ) оператор else оператор switch оператор switch ( выражение ) оператор
 while ( выражение ) оператор do оператор while (выражение) for ( оператор выражение opt; выражение opt ) оператор
 case константное_выражение : оператор default : оператор break ; continue ;
 return выражение opt ;
 goto идентификатор ; идентификатор : оператор
 список_операторов: оператор оператор список_операторов
 Заметьте, что описание является оператором, и что нет операторов присваивания и вызова процедуры. Присваивание и вызов функции обрабатываются как выражения.




 3.3.1 Проверки


 Проверка значения может осуществляться или оператором if, или оператором switch:
 if ( выражение ) оператор if ( выражение ) оператор else оператор switch ( выражение ) оператор
 В С++ нет отдельного булевского типа. Операции сравнения
 == != « „= “ »=
 возвращают целое 1, если сравнение истинно, иначе возращают 0. Не так уж непривычно видеть, что ИСТИНА определена как 1, а ЛОЖЬ определена как 0.
 В операторе if первый (или единственный) оператор выпоняется в том случае, если выражение ненулевое, иначе выполнется второй оператор (если он задан). Отсюда следует, что в качестве условия может использоваться любое целое выражение. В частности, если a целое, то
 if (a) // ...
 эквивалентно
 if (a != 0) // ...
 Логические операции amp; amp; !! ! наиболее часто используются в условиях. Операции amp; amp; и !! не будут вычислять второй аргмент, если это ненужно. Например:
 if (p amp; amp; 1«p-»count) // ...
 вначале проверяет, является ли p не нулем, и только если это так, то проверяет 1«p-»count.
 Некоторые простые операторы if могут быть с удобством
 заменены выражениями арифметического if. Например:
 if (a «= d) max = b; else max = a;
 лучше выражается так:
 max = (a«=b) ? b : a;
 Скобки вокруг условия необязательны, но я считаю, что когда они используются, программу легче читать.
 Некоторые простые операторы switch можно по-другому зписать в виде набора операторов if. Например:
 switch (val) (* case 1: f(); break; case 2; g(); break; default: h(); break; *)
 иначе можно было бы записать так:
 if (val == 1) f(); else if (val == 2) g(); else h();
 Смысл тот же, однако первый вариант (switch) предпочттельнее, поскольку в этом случае явно выражается сущность действия (сопоставление значения с рядом констант). Поэтому в нетривиальных случаях оператор switch читается легче.
 Заботьтесь о том, что switch должен как-то завершаться, если только вы не хотите, чтобы выполнялся следующий case. Например:
 switch (val) (* // осторожно case 1: cout «„ „case 1\n“; case 2; cout „« «case 2\n“; default: cout «« «default: case не найден\n“; *)
 при val==1 напечатает
 case 1 case 2 default: case не найден
 к великому изумлению непосвященного. Самый обычный спсоб завершить случай – это break, иногда можно даже использвать goto. Например:
 switch (val) (* // осторожно
 case 0: cout «„ „case 0\n“; case1: case 1: cout „„ «case 1\n“; return; case 2; cout «« «case 2\n“; goto case1; default: cout «« «default: case не найден\n“; return; *)
 При обращении к нему с val==2 выдаст
 case 2 case 1
 Заметьте, что метка case не подходит как метка для упоребления в операторе goto:
 goto case 1; // синтаксическая ошибка




 3.3.2 Goto


 С++ снабжен имеющим дурную репутацию оператором goto.
 goto идентификатор; идентификатор : оператор
 В общем, в программировании высокого уровня он имеет очень мало применений, но он может быть очень полезен, когда С++ программа генерируется программой, а не пишется непоредственно человеком. Например, операторы goto можно исползовать в синтаксическом анализаторе, порождаемом генератором синтаксических анализаторов. Оператор goto может быть также важен в тех редких случаях, когда важна наилучшая эффектиность, например, во внутреннем цикле какой-нибудь программы, работающей в реальном времени.
 Одно из немногих разумных применений состоит в выходе из вложенного цикла или переключателя (break лишь прекращает вполнение самого внутреннего охватывающего его цикла или преключателя). Например:
 for (int i = 0; i«n; i++) for (int j = 0; j«m; j++) if (nm[i][j] == a) goto found // найдено // не найдено // ...
 found: // найдено // nm[i][j] == a
 Имеется также оператор continue, который по сути делает переход на конец оператора цикла, как объясняется в #3.1.5.




 3.4 Комментарии и Выравнивание


 Продуманное использование комментариев и согласованное использование отступов может сделать чтение и понимание прораммы намного более приятным. Существует несколько различных стилей согласованного использования отступов. Автор не видит никаких серьезных оснований предпочесть один другому (хотя как и у большинства, у меня есть свои предпочтения). Сказаное относится также и к стилю комментариев.
 Неправильное использование комментариев может серьезно повлиять на удобочитаемость программы, Компилятор не понимает содержание комментария, поэтому он никаким способом не может убедиться в том, что комментарий
 1. осмыслен,
 2. описывает программу и
 3. не устарел.
 Непонятные, двусмысленные и просто неправильные комметарии содержатся в большинстве программ. Плохой комментарий может быть хуже, чем никакой.
 Если что-то можно сформулировать средствами самого язка, следует это сделать, а не просто отметить в комментарии. Данное замечание относится к комментариям вроде:
 // переменная "v" должна быть инициализирована.
 //переменная"v"должна использоваться только функцией «f()».
 // вызвать функцию init() перед вызовом // любой другой функции в этом файле.
 // вызовите функцию очистки «cleanup()» в конце вашей // программы.
 // не используйте функцию «wierd()».
 // функция «f()» получает два параметра.
 При правильном использовании С++ подобные комментарии как правило становятся ненужными. Чтобы предыдущие комментрии стали излишними, можно, например, использовать правила компоновки (#4.2) и видимость, инициализацию и правила очиски для классов (см. #5.5.2).
 Если что-то было ясно сформулировано на языке, второй раз упоминать это в комментарии не следует. Например:
 a = b+c; // a становится b+c count++; // увеличить счетчик
 Такие комментарии хуже чем просто излишни, они увеличвают объем текста, который надо прочитать, они часто затумнивают структуру программы, и они могут быть неправильными.
 Автор предпочитает:
 1. Комментарий для каждого исходного файла, сообщающий, для чего в целом предназначены находящиеся в нем комментарии, дающий ссылки на справочники и руководства, общие рекомендции по использованию и т.д.,
 2. Комментарий для каждой нетривиальной функции, в ктором сформулировано ее назначение, используемый алгоритм (если он неочевиден) и, быть может, что-то о принимаемых в ней предположениях относительно среды выполнения,
 3. Небольшое число комментариев в тех местах, где прорамма неочевидна и/или непереносима и
 4. Очень мало что еще.
 Например:
 // tbl.c: Реализация таблицы имен /* Гауссовское исключение с частичным См. Ralston: «A first course ...» стр. 411. */
 // swap() предполагает размещение стека AT amp;T sB20.
 /**************************************
 Copyright (c) 1984 AT amp;T, Inc. All rights reserved
 ****************************************/
 Удачно подобранные и хорошо написанные комментарии – сщественная часть программы. Написание хороших комментариев может быть столь же сложным, сколь и написание самой програмы.
 Заметьте также, что если в функции используются исключтельно комментарии //, то любую часть этой функции можно зкомментировать с помощью комментариев /* */, и наоборот.




 3.5 Упражнения


 1. (*1) Перепишите следующий оператор for в виде эквивалентного оператора while: for (i=0; i«max_length; i++) if (input_line[i] == '?') quest_count++;
 2. (*1) Полностью расставьте скобки в следующих выражниях: a = b + c * d «« 2 amp; 8 a amp; 077 != 3 a == b !! a == c amp; amp; c « 5 c = x != 0 0 «= i « 7 f(1,2)+3 a = -1 + + b – – 5 a = b == c ++ a = b = c = 0 a[4][2] *= * b ? c : * d * 2 a-b,c=d
 3. (*2) Найдите пять различных конструкций С++, значение которых неопределено.
 4. (*2) Найдите десять различных примеров непереносимой С++ программы.
 5. (*1) Что происходит в вашей системе, если вы делите на ноль? Что происходит при переполнении и потере значимости?
 6. (*1) Полностью расставьте скобки в следующих выражниях: *p++ *–p ++a– (int*)p-»m *p.m *a[i]
 7. (*2) Напишите функции: strlen(), которая возвращает длину строки, strcpy(), которая копирует одну строку в дргую, и strcmp(), которая сравнивает две строки. Разберитесь, какие должны быть типы параметров и типы возвращаемых значний, а потом сравните их со стандартными версиями, которые описаны в «string.h» и в вашем руководстве.
 8. (*1) Посмотрите, как ваш компилятор реагирует на ошибки: a := b+1; if (a = 3) // ... if (a amp;077 == 0) // Придумайте ошибки попроще, и посмотрите, как компилятор на них реагирует.
 9. (*2) Напишите функцию cat(), получающую два строковых параметра и возвращающую строку, которая является конкатенцией параметров. Используйте new, чтобы найти память для рзультата. Напишите функцию rev(), которая получает строку и переставляет в ней символы в обратном порядке. То есть, после вызова rev(p) последний символ p становится первым.
 10. (*2) Что делает следующая программа?
 void send(register* to, register* from, register count) // Полезные комментарии несомненно уничтожены. (* register n=(count+7)/8; switch (count%8) (* case 0: do (* *to++ = *from++; case 7: do (* *to++ = *from++; case 6: do (* *to++ = *from++; case 5: do (* *to++ = *from++; case 4: do (* *to++ = *from++; case 3: do (* *to++ = *from++; case 2: do (* *to++ = *from++; case 1: do (* *to++ = *from++; while (–n»0); *) *) Зачем кто-то мог написать нечто похожее?
 11. (*2) Напишите функцию atoi(), которая получает стрку, содержащую цифры, и возвращает соответствующее int. Наример, atoi(«123») – это 123. Модифицируйте atoi() так, чтобы помимо обычной десятичной она обрабатывала еще восьмеричную и шестнадцатиричную записи С++. Модифицируйте atoi() так, чтобы обрабатывать запись символьной константы. Напишите функцию itoa(), которая строит представление целого параметра в виде строки.
 12. (*2) Перепишите get_token() (#3.1.2), чтобы она за один раз читала строку в буфер, а затем составляла лексемы, читая символы из буфера.
 13. (*2) Добавьте в настольный калькулятор из #3.1 такие функции, как sqrt(), log() и sin(). Подсказка: предопределите имена и вызывайте функции с помощью вектора указателей на функции. Не забывайте проверять параметры в вызове функции.
 14. (*3) Дайте пользователю возможность определять фунции в настольном калькуляторе. Подсказка: определяйте функции как последовательность действий, прямо так, как их набрал пользователь. Такую последовательность можно хранить или как символьную строку, или как список лексем. После этого, когда функция вызывается, читайте и выполняйте эти действия. Если вы хотите, чтобы пользовательская функция получала параметры, вы должны придумать форму записи этого.
 15. (*1.5) Преобразуйте настольный калькулятор так, чтбы вместо статических переменных name_string и number_value использовалась структура символа symbol: struct symbol (* token_value tok; union (* double number_value; char* name_string; *); *);
 16. (*2.5) Напишите программу, которая выбрасывает коментарии из С++ программы. То есть, читает из cin, удаляет // и /* */ комментарии и пишет результат в cout. Не заботьтесь о приятном виде выходного текста (это могло бы быть другим, блее сложным упражнением). Не беспокойтесь о правильности программ. Остерегайтесь // и /* и */ внутри комментариев, строк и символьных констант.
 17. (*2) Посмотрите какие-нибудь программы, чтобы понять принцип различных стилей комментирования и выравнивания, кторые используются на практике.




 Глава 4 Функции и Файлы



 Итерация свойственна человеку, рекурсия божественна.

    Л. Питер Дойч

 Все нетривиальные программы собираются из нескольких раздельно компилируемых единиц (их принято называть просто файлами). В этой главе описано, как раздельно откомпилированые функции могут обращаться друг к другу, как такие функции могут совместно пользоваться данными (разделять данные), и как можно обеспечить согласованность типов, которые использются в разных файлах программы. Функции обсуждаются довольно подробно. Сюда входят передача параметров, параметры по умочанию, перегрузка имен функций, и, конечно же, описание и оределение функций. В конце описываются макросы.




 4.1 Введение


 Иметь всю программу в одном файле обычно невозможно, поскольку коды стандартных библиотек и операционной системы находятся где-то в другом месте. Кроме того, хранить весь текст пользовательской программы в одном файле как правило непрактично и неудобно. Способ организации программы в файлы может помочь читающему охватить всю структуру программы, а также может дать возможность компилятору реализовать эту структуру. Поскольку единицей компиляции является файл, то во всех случаях, когда в файл вносится изменение (сколь бы мало оно ни было), весь файл нужно компилировать заново. Даже для программы умеренных размеров время, затрачиваемое на перекопиляцию, можно значительно снизить с помощью разбиения прораммы на файлы подходящих размеров.
 Рассмотрим пример с калькулятором. Он был представлен в виде одного исходного файла. Если вы его набили, то у вас нверняка были небольшие трудности с расположением описаний в правильном порядке, и пришлось использовать по меньшей мере одно «фальшивое» описание, чтобы компилятор смог обработать взаимно рекурсивные функции expr(), term() и prim(). В тексте уже отмечалось, что программа состоит из четырех частей (лесического анализатора, программы синтаксического разбора, таблицы имен и драйвера), но это никак не было отражено в тексте самой программы. По сути дела, калькулятор был написан по-другому. Так это не делается; даже если в этой программе «на выброс» пренебречь всеми соображениями методологии прораммирования, эксплуатации и эффективности компиляции, автор все равно разобьет эту программу в 200 строк на несколько файлов, чтобы программировать было приятнее.
 Программа, состоящая из нескольких раздельно компилирумых файлов, должна быть согласованной в смысле использования имен и типов, точно так же, как и программа, состоящая из оного исходного файла. В принципе, это может обеспечить и копоновщик*. Компоновщик – это программа, стыкующая отдельно скомпилированные части вместе. Компоновщик часто (путая) нзывают загрузчиком. В UNIX'е компоновщик называется ld. Однко компоновщики, имеющиеся в большинстве систем, обеспечивают очень слабую поддержку проверки согласованности.
 – * или линкер. (прим. перев.)
 Программист может скомпенсировать недостаток поддержки со стороны компоновщика, предоставив дополнительную информцию о типах (описания). После этого согласованность программы обеспечивается проверкой согласованности описаний, которые
 находятся в отдельно компилируемых частях. Средства, которые это обеспечивают, в вашей системе будут. С++ разработан так, чтобы способствовать такой явной компоновке*.
 – * C разработан так, чтобы в большинстве случаев позвлять осуществлять неявную компоновку. Применение C, однако, возросло неимоверно, поэтому случаи, когда можно использовать неявную линковку, сейчас составляют незначительное меньшинтво. (прим. автора)




 4.2 Компоновка


 Если не указано иное, то имя, не являющееся локальным для функции или класса, в каждой части программы, компилирумой отдельно, должно относиться к одному и тому же типу, знчению, функции или объекту. То есть, в программе может быть только один нелокальный тип, значение, функция или объект с этим именем. Рассмотрим, например, два файла:
 // file1.c: int a = 1; int f() (* /* что-то делает */ *)
 // file2.c: extern int a; int f(); void g() (* a = f(); *)
 a и f(), используемые g() в файле file2.c,– те же, что определены в файле file1.c. Ключевое слово extern (внешнее) указывает, что описание a в file2.c является (только) описнием, а не определением. Если бы a инициализировалось, extern было бы просто проигнорировано, поскольку описание с иницилизацией всегда является определением. Объект в программе должен определяться только один раз. Описываться он может много раз, но типы должны точно согласовываться. Например:
 // file1.c: int a = 1; int b = 1; extern int c;
 // file2.c: int a; extern double b; extern int c;
 Здесь три ошибки: a определено дважды (int a; является определением, которое означает int a=0;), b описано дважды с разными типами, а c описано дважды, но не определено. Эти вды ошибок не могут быть обнаружены компилятором, который за один раз видит только один файл. Компоновщик, однако, их онаруживает.
 Следующая программа не является С++ программой (хотя C программой является):
 // file1.c: int a; int f() (* return a; *)
 // file2.c: int a; int g() (* return f(); *)
 Во-первых, file2.c не С++, потому что f() не была описана, и поэтому компилятор будет недоволен. Во-вторых, (когда file2.c фиксирован) программа не будет скомпонована, посколку a определено дважды.
 Имя можно сделать локальным в файле, описав его static. Например:
 // file1.c: static int a = 6; static int f() (* /* ... */ *)
 // file2.c: static int a = 7; static int f() (* /* ... */ *)
 Поскольку каждое a и f описано как static, получающаяся в результате программа является правильной. В каждом файле своя a и своя f().
 Когда переменные и функции явно описаны как static, часть программы легче понять (вам не надо никуда больше залядывать). Использование static для функций может, помимо этого, выгодно влиять на расходы по вызову функции, поскольку дает оптимизирующему компилятору более простую работу.
 Рассмотрим два файла:
 // file1.c: const int a = 6; inline int f() (* /* ... */ *) struct s (* int a,b; *)
 // file1.c: const int a = 7; inline int f() (* /* ... */ *) struct s (* int a,b; *)
 Раз правило «ровно одно определение» применяется к контантам, inline-функциям и определениям функций так же, как оно применяется к функциям и переменным, то file1.c и file2.c не могут быть частями одной С++ программы. Но если это так, то как же два файла могут использовать одни и те же типы и константы? Коротко, ответ таков: типы, константы и т.п. могут определяться столько раз, сколько нужно, при условии, что они определяются одинаково. Полный ответ несколько более сложен (это объясняется в следующем разделе).




 4.3 Заголовочные Файлы


 Типы во всех описаниях одного и того же объекта должны быть согласованными. Один из способов это достичь мог бы сотоять в обеспечении средств проверки типов в компоновщике, но большинство компоновщиков – образца 1950-х, и их нельзя измнить по практическим соображениям*. Другой подход состоит в обеспечении того, что исходный текст, как он передается на рассмотрение компилятору, или согласован, или содержит инфомацию, которая позволяет компилятору обнаружить несогласованости. Один несовершенный, но простой способ достичь согласванности состоит во включении заголовочных файлов, содержащих интерфейсную информацию, в исходные файлы, в которых содежится исполняемый код и/или определения данных.
 – * Легко изменить один компоновщик, но сделав это и напсав программу, которая зависит от усовершенствований, как вы будете переносить эту программу в другое место? (прим. автра)
 Механизм включения с помощью #include – это чрезвычайно простое средство обработки текста для сборки кусков исходной программы в одну единицу (файл) для ее компиляции. Директива
 #include «to_be_included»
 замещает строку, в которой встретилось #include, содежимым файла «to_be_included». Его содержимым должен быть иходный текст на С++, поскольку дальше его будет читать комплятор. Часто включение обрабатывается отдельной программой, называемой C препроцессором, которую команда CC вызывает для преобразования исходного файла, который дал программист, в файл без директив включения перед тем, как начать собственно компиляцию. В другом варианте эти директивы обрабатывает итерфейсная система компилятора по мере того, как они встречются в исходном тексте. Если программист хочет посмотреть на результат директив включения, можно воспользоваться командой
 CC -E file.c
 для препроцессирования файла file.c точно также, как это сделала бы CC перед запуском собственно компилятора. Для включения файлов из стандартной директории включения вместо кавычек используются угловые скобки « и ». Например:
 #include «stream.h» //из стандартной директории включения #define «myheader.h» // из текущей директории
 Использование «» имеет то преимущество, что в программу фактическое имя директории включения не встраивается (как правило, сначала просматривается /usr/include/CC, а потом usr /include). К сожалению, пробелы в директиве include сущесвенны:
 #include « stream.h » // не найдет «stream.h»
 Может показаться, что перекомпилировать файл заново кадый раз, когда он куда-либо включается, расточительно, но время компиляции такого файла обычно слабо отличается от врмени, которое необходимо для чтения его некоторой заранее окомпилированной формы. Причина в том, что текст программы яляется довольно компактным представлением программы, и в том, что включаемые файлы обычно содержат только описания и не сдержат программ, требующих от компилятора значительного анлиза.
 Следующее эмпирическое правило относительно того, что следует, а что не следует помещать в заголовочные файлы, яляется не требованием языка, а просто предложением по разуному использованию аппарата #include.
 В заголовочном файле могут содержаться:
 Определения типов struct point (* int x, y; *) Описания функций extern int strlen(const char*); Определения inline-функ-й inline char get()(*return *p++;*) Описания данных extern int a; Определения констант const float pi = 3.141593 Перечисления enum bool (* false, true *); Директивы include #include «signal.h» Определения макросов #define Case break;case Комментарии /* проверка на конец файла */
 но никогда
 Определения обычных функций char get() (* return *p++; *) Определения данных int a;
 Определения сложных константных объектов const tbl[]=(*/* ... */ *)
 В системе UNIX принято, что заголовочные файлы имеют суффикс (расширение) .h. Файлы, содержащие определение данных или функций, должны иметь суффикс .c. Такие файлы часто назвают, соответственно, «.h файлы» и «.c файлы». В #4.7 описваются макросы. Следует заметить, что в С++ макросы гораздо менее полезны, чем в C, поскольку С++ имеет такие языковые конструкции, как const для определения констант и inline для исключения расходов на вызов функции.
 Причина того, почему в заголовочных файлах допускается определение простых констант, но не допускается определение сложных константных объектов, прагматическая. В принципе, сложность тут только в том, чтобы сделать допустимым дублирвание определений переменных (даже определения функций можно было бы дублировать). Однако для компоновщиков старого обраца слишком трудно проверять тождественность нетривиальных констант и убирать ненужные повторы. Кроме того, простые слчаи гораздо более обиходны и потому более важны для генерации хорошего кода.




 4.3.1 Один Заголовочный Файл


 Проще всего решить проблему разбиения программы на неколько файлов поместив функции и определения данных в подхдящее число исходных файлов и описав типы, необходимые для их взаимодействия, в одном заголовочном файле, который включаеся во все остальные файлы. Для программы калькулятора можно использовать четыре .c файла: lex.c, syn.c, table.c и main.c, и заголовочный файл dc.h, содержащий описания всех имен, кторые используются более чем в одном .c файле:
 // dc.h: общие описания для калькулятора
 enum token_value (* NAME, NUMBER, END, PLUS='+', MINUS='-', MUL='*', DIV='/', PRINT=';', ASSIGN='=', LP='(', RP=')' *);
 extern int no_of_errors; extern double error(char* s); extern token_value get_token(); extern token_value curr_tok; extern double number_value; extern char name_string[256];
 extern double expr(); extern double term(); extern double prim();
 struct name (* char* string; name* next; double value; *);
 extern name* look(char* p, int ins = 0); inline name* insert(char* s) (* return look(s,1); *)
 Если опустить фактический код, то lex.c будет выглядеть примерно так:
 // lex.c: ввод и лексический анализ #include «dc.h»
 #include «ctype.h»
 token_value curr_tok; double number_value; char name_string[256];
 token_value get_token() (* /* ... */ *)
 Заметьте, что такое использование заголовочных файлов гарантирует, что каждое описание в заголовочном файле объета, определенного пользователем, будет в какой-то момент включено в файл, где он определяется. Например, при компилции lex.c компилятору будет передано:
 extern token_value get_token(); // ... token_value get_token() (* /* ... */ *)
 Это обеспечивает то, что компилятор обнаружит любую нсогласованность в типах, указанных для имени. Например, если бы get_token() была описана как возвращающая token_value, но при этом определена как возвращающая int, компиляция lex.c не прошла бы изза ошибки несоответствия типов.
 Файл syn.c будет выглядеть примерно так:
 // syn.c: синтаксический анализ и вычисление
 #include «dc.h»
 double prim() (* /* ... */ *) double term() (* /* ... */ *) double expr() (* /* ... */ *)
 Файл table.c будет выглядеть примерно так:
 // table.c: таблица имен и просмотр
 #include «dc.h»
 extern char* strcmp(const char*, const char*); extern char* strcpy(char*, const char*); extern int strlen(const char*);
 const TBLSZ = 23; name* table[TBLSZ];
 name* look(char* p; int ins) (* /* ... */ *)
 Заметьте, что table.c сам описывает стандартные функции для работы со строками, поэтому никакой проверки согласованости этих описаний нет. Почти всегда лучше включать заголвочный файл, чем описывать имя в .c файле как extern. При этом может включаться «слишком много», но это обычно не окзывает серьезного влияния на время, необходимое для компилции, и как правило экономит время программиста. В качестве примера этого, обратите внимание на то, как strlen() заново описывается в main() (ниже). Это лишние нажатия клавиш и воможный источник неприятностей, поскольку компилятор не может проверить согласованность этих двух определений. На самом дле, этой сложности можно было бы избежать, будь все описания extern помещены в dc.h, как и предлагалось сделать. Эта «нережность» сохранена в программе, поскольку это очень типично для C программ, очень соблазнительно для программиста, и чаще приводит, чем не приводит, к ошибкам, которые трудно обнаржить, и к программам, с которыми тяжело работать. Вас предуредили!
 И main.c, наконец, выглядит так:
 // main.c: инициализация, главный цикл и обработка ошибок
 #include «dc.h»
 int no_of_errors;
 double error(char* s) (* /* ... */ *)
 extern int strlen(const char*);
 main(int argc, char* argv[]) (* /* ... */ *)
 Важный случай, когда размер заголовочных файлов станвится серьезной помехой. Набор заголовочных файлов и библиотеку можно использовать для расширения языка множеством общи специальноприкладных типов (см. Главы 5-8). В таких случаях не принято осуществлять чтение тысяч строк заголовоных файлов в начале каждой компиляции. Содержание этих файлов обычно «заморожено» и изменяется очень нечасто. Наиболее плезным может оказаться метод затравки компилятора содержанием этих заголовочных фалов. По сути, создается язык специального назначения со своим собственным компилятором. Никакого стадартного метода создания такого компилятора с затравкой не принято.




 4.3.2 Множественные Заголовочные Файлы


 Стиль разбиения программы с одним заголовочным файлом наиболее пригоден в тех случаях, когда программа невелика и ее части не предполагается использовать отдельно. Поэтому то, что невозможно установить, какие описания зачем помещены в заголовочный файл, несущественно. Помочь могут комментарии. Другой способ – сделать так, чтобы каждая часть программы имела свой заголовочный файл, в котором определяются предотавляемые этой частью средства. Тогда каждый .c файл имеет соответствующий .h файл, и каждый .c файл включает свой собтвенный (специфицирующий то, что в нем задается) .h файл и, возможно, некоторые другие .h файлы (специфицирующие то, что ему нужно).
 Рассматривая организацию калькулятора, мы замечаем, что error() используется почти каждой функцией программы, а сама использует только «stream.h». Это обычная для функции ошибок ситуация, поэтому error() следует отделить от main():
 // error.h: обработка ошибок
 extern int no_errors;
 extern double error(char* s);
 // error.c
 #include «stream.h» #include «error.h»
 int no_of_errors;
 double error(char* s) (* /* ... */ *)
 При таком стиле использования заголовочных файлов .h файл и связанный с ним .c файл можно рассматривать как мдуль, в котором .h файл задает интерфейс, а .c файл задает реализацию. Таблица символов не зависит от остальной части калькулятора за исключением использования функции ошибок. Это можно сделать явным:
 // table.h: описания таблицы имен
 struct name (* char* string; name* next; double value; *);
 extern name* look(char* p, int ins = 0); inline name* insert(char* s) (* return look(s,1); *)
 // table.c: определения таблицы имен
 #include «error.h» #include «string.h» #include «table.h»
 const TBLSZ = 23; name* table[TBLSZ];
 name* look(char* p; int ins) (* /* ... */ *)
 Заметьте, что описания функций работы со строками теперь включаются из «string.h». Это исключает еще один возможный источник ошибок.
 // lex.h: описания для ввода и лексического анализа
 enum token_value (* NAME, NUMBER, END, PLUS='+', MINUS='-', MUL='*', DIV='/', PRINT=';', ASSIGN='=', LP='(', RP=')' *);
 extern token_value curr_tok; extern double number_value; extern char name_string[256];
 extern token_value get_token();
 Этот интерфейс лексического анализатора достаточно бепорядочен. Недостаток в надлежащем типе лексемы обнаруживает себя в необходимости давать пользователю get_token() фактческие лексические буферы number_value и name_string.
 // lex.c: определения для ввода и лексического анализа
 #include «stream.h» #include «ctype.h» #include «error.h» #include «lex.h»
 token_value curr_tok; double number_value; char name_string[256];
 token_value get_token() (* /* ... */ *)
 Интерфейс синтаксического анализатора совершенно прозрчен: // syn.c: описания для синтаксического анализа и вычисления
 extern double expr(); extern double term();
 extern double prim();
 // syn.c: определения для синтаксического анализа и // вычисления
 #include «error.h» #include «lex.h» #include «syn.h»
 double prim() (* /* ... */ *) double term() (* /* ... */ *) double expr() (* /* ... */ *)
 Главная программа, как всегда, тривиальна:
 // main.c: главная программа
 #include «stream.h» #include «error.h» #include «lex.h» #include «syn.h» #include «table.h» #include «string.h»
 main(int argc, char* argv[]) (* /* ... */ *)
 Сколько заголовочных файлов использовать в программе, зависит от многих факторов. Многие из этих факторов сильнее связаны с тем, как ваша система работает с заголовочными фалами, нежели с С++. Например, если в вашем редакторе нет средств, позволяющих одновременно видеть несколько файлов, использование большого числа файлов становится менее привлкательным. Аналогично, если открывание и чтение 10 файлов по 50 строк в каждом требует заметно больше времени, чем чтение одного файла в 500 строк, вы можете дважды подумать, прежде чем использовать в небольшом проекте стиль множественных зголовочных файлов. Слово предостережения: набор из десяти зголовочных файлов плюс стандартные заголовочные файлы обычно легче поддаются управлению. С другой стороны, если вы разбили описания в большой программе на логически минимальные по рамеру заголовочные файлы (помещая каждое описание структуры в свой отдельный файл и т.д.), у вас легко может получиться нразбериха из сотен файлов.




 4.3.3 Сокрытие Данных


 Используя заголовочные файлы пользователь может опредлять явный интерфейс, чтобы обеспечить согласованное исползование типов в программе. С другой стороны, пользователь может обойти интерфейс, задаваемый заголовочным файлом, вводя в .c файлы описания extern.
 Заметьте, что такой стиль компоновки не рекомендуется:
 // file1.c: // «extern» не используется int a = 7; const c = 8; void f(long) (* /* ... */ *)
 // file2.c: // «extern» в .c файле extern int a; extern const c; extern f(int); int g() (* return f(a+c); *)
 Поскольку описания extern в file2.c не включаются вместе с определениями в файле file1.c, компилятор не может проверить согласованность этой программы. Следовательно, если только загрузчик не окажется гораздо сообразительнее среднго, две ошибки в этой программе останутся, и их придется икать программисту.
 Пользователь может защитить файл от такой недисциплинрованной компоновки, описав имена, которые не предназначены для общего пользования, как static, чтобы их областью видмости был файл, и они были скрыты от остальных частей прораммы. Например:
 // table.c: определения таблицы имен
 #include «error.h» #include «string.h» #include «table.h»
 const TBLSZ = 23; static name* table[TBLSZ];
 name* look(char* p; int ins) (* /* ... */ *)
 Это гарантирует, что любой доступ к table действительно будет осуществляться именно через look(). «Прятать» константу TBLSZ не обязательно.




 4.4 Файлы как Модули


 В предыдущем разделе .c и .h файлы вместе определяли часть программы. Файл .h является интерфейсом, который ипользуют другие части программы, .c файл задает реализацию. Такой объект часто называют модулем. Доступными делаются только те имена, которые необходимо знать пользователю, отальные скрыты. Это качество часто называют сокрытием данных, хотя данные – лишь часть того, что может быть скрыто. Модули такого вида обеспечивают большую гибкость. Например, реализция может состоять из одного или более .c файлов, и в виде .h файлов может быть предоставлено несколько интерфейсов. Инфомация, которую пользователю знать не обязательно, искусно скрыта в .c файлах. Если важно, что пользователь не должен точно знать, что содержится в .c файлах, не надо делать их доступными в исходом виде. Достаточно эквивалентных им выхоных файлов компилятора (.o файлов).
 Иногда возникает сложность, состоящая в том, что подоная гибкость достигается без формальной структуры. Сам язык не распознает такой модуль как объект, и у компилятора нет возможности отличить .h файлы, определяющие имена, которые должны использовать другие модули (экспортируемые), от .h файлов, которые описывают имена из других модулей (импортиремые).
 В других случаях может возникнуть та проблема, что мдуль определяет множество объектов, а не новый тип. Например, модуль table определяет одну таблицу, и если вам нужно две таблицы, то нет простого способа задать вторую таблицу с пмощью понятия модуля. Решение этой проблемы приводится в Глве 5.
 Каждый статически размещенный объект по умолчанию иницализируется нулем, программист может задать другие (константные) значения. Это только самый примитивный вид инциализации. К счастью, с помощью классов можно задать код, который выполняется для инициализации перед тем, как модуль какимлибо образом используется, и/или код, который запускаеся для очистки после последнего использования модуля, см. #5.5.2.




 4.5 Как Создать Библиотеку


 Фразы типа «помещен в библиотеку» и «ищется в какой-то библиотеке» используются часто (и в этой книге, и в других), но что это означает для С++ программы? К сожалению, ответ звисит от того, какая операционная система используется; в этом разделе объясняется, как создать библиотеку в 8-ой весии системы UNIX. Другие системы предоставляют аналогичные возможности.
 Библиотека в своей основе является множеством .o файлов, полученных в результате компиляции соответствующего множества .c файлов. Обычно имеется один или более .h файлов, в которых содержатся описания для использования этих .o файлов. В кчестве примера рассмотрим случай, когда нам надо задать (обычным способом) набор математических функций для некоторго неопределенного множества пользователей. Заголовочный файл мог бы выглядеть примерно так:
 extern double sqrt(double); // подмножество «math.h» extern double sin(double); extern double cos(double); extern double exp(double); extern double log(double);
 а определения этих функций хранились бы, соответственно, в файлах sqrt.c, sin.c, cos.c, exp.c и log.c.
 Библиотеку с именем math.h можно создать, например, так:
 $ CC -c sqrt.c sin.c cos.c exp.c log.c $ ar cr math.a sqrt.o sin.o cos.o exp.o log.o $ ranlib math.a
 Вначале исходные файлы компилируются в эквивалентные им объектные файлы. Затем используется команда ar, чтобы создать архив с именем math.a. И, наконец, этот архив индексируется для ускорения доступа. Если в вашей системе нет ranlib комады, значит она вам, вероятно, не понадобится. Подробности посмотрите, пожалуйста, в вашем руководстве в разделе под зголовком ar. Использовать библиотеку можно, например, так:
 $ CC myprog.c math.a
 Теперь разберемся, в чем же преимущества использования math.a перед просто непосредственным использованием .o фалов? Например:
 $ CC myprog.c sqrt.o sin.o cos.o exp.o log.o
 Для большинства программ определить правильный набор .o файлов, несомненно, непросто. В приведенном выше примере они включались все, но если функции в myprog.c вызывают только функции sqrt() и cos(), то кажется, что будет достаточно
 $ CC myprog.c sqrt.o cos.o
 Но это не так, поскольку cos.c использует sin.c.
 Компоновщик, вызываемый командой CC для обработки .a файла (в данном случае, файла math.a) знает, как из того мнжества, которое использовалось для создания .a файла, извлечь только необходимые .o файлы.
 Другими словами, используя библиотеку можно включать много определений с помощью одного имени (включения определний функций и переменных, используемых внутренними функциями,
 никогда не видны пользователю), и, кроме того, обеспечить, что в результате в программу будет включено минимальное колчество определений.




 4.6 Функции


 Обычный способ сделать что-либо в С++ программе – это вызвать функцию, которая это делает. Определение функции яляется способом задать то, как должно делаться некоторое действие. Функция не может быть вызвана, пока она не описана.




 4.6.1 Описания Функций


 Описание функции задает имя функции, тип возвращаемого функцией значения (если таковое есть) и число и типы парамеров, которые должны быть в вызове функции. Например:
 extern double sqrt(double); extern elem* next_elem(); extern char* strcpy(char* to, const char* from); extern void exit(int);
 Семантика передачи параметров идентична семантике иницализации. Проверяются типы параметров, и когда нужно произвдится неявное преобразование типа. Например, если были заданы предыдущие определения, то
 double sr2 = sqrt(2);
 будет правильно обращаться к функции sqrt() со значением с плавающей точкой 2.0. Значение такой проверки типа и преоразования типа огромно.
 Описание функции может содержать имена параметров. Это может помочь читателю, но компилятор эти имена просто игноррует.




 4.6.2 Определения Функций


 Каждая функция, вызываемая в программе, должна быть гдто определена (только один раз). Определение функции – это описание функции, в котором приводится тело функции. Напрмер:
 extern void swap(int*, int*); // описание
 void swap(int*, int*) // определение (* int t = *p; *p =*q; *q = t; *)
 Чтобы избежать расходов на вызов функции, функцию можно описать как inline (#1.12), а чтобы обеспечить более быстрый доступ к параметрам, их можно описать как register (#2.3.11). Оба средства могут использоваться неправильно, и их следует избегать везде где есть какие-либо сомнения в их полезности.




 4.6.3 Передача Параметров


 Когда вызывается функция, дополнительно выделяется пмять под ее формальные параметры, и каждый формальный парметр инициализируется соответствующим ему фактическим парметром. Семантика передачи параметров идентична семантике инициализации. В частности, тип фактического параметра сопотавляется с типом формального параметра, и выполняются все
 стандартные и определенные пользователем преобразования тпов. Есть особые правила для передачи векторов (#4.6.5), средство передавать параметр без проверки типа параметра (#4.6.8) и средство для задания параметров по умолчанию (#4.6.6). Рассмотрим
 void f(int val, int amp; ref) (* val++; ref++; *)
 Когда вызывается f(), val++ увеличивает локальную копию первого фактического параметра, тогда как ref++ увеличивает второй фактический параметр. Например:
 int i = 1; int j = 1; f(i,j);
 увеличивает j, но не i. Первый параметр – i, передается по значению, второй параметр – j, передается по ссылке. Как уже отмечалось в #2.3.10, использование функций, которые именяют переданные по ссылке параметры, могут сделать програму трудно читаемой, и их следует избегать (но см. #6.5 и #8.4). Однако передача большого объекта по ссылке может быть гораздо эффективнее, чем передача его по значению. В этом случае параметр можно описать как const, чтобы указать, что ссылка применяется по соображениям эффективности, а также чтобы не позволить вызываемой функции изменять значение обекта:
 void f(const large amp; arg) (* // значение «arg» не может быть изменено *)
 Аналогично, описание параметра указателя как const соощает читателю, что значение объекта, указываемого указателем, функцией не изменяется. Например:
 extern int strlen(const char*); // из «string.h» extern char* strcpy(char* to, const char* from); extern int strcmp(const char*, const char*);
 Важность такой практики возрастает с размером программы.
 Заметьте, что семантика передачи параметров отлична от семантики присваивания. Это важно для const параметров, сслочных параметров и параметров некоторых типов, определяемых пользователем (#6.6).




 4.6.4 Возврат Значения


 Из функции, которая не описана как void, можно (и долно) возвращать значение. Возвращаемое значение задается опратором return. Например:
 int fac(int n) (*return (n»1) ? n*fac(n-1) : 1; *)
 В функции может быть больше одного оператора return: int fac(int n) (* if (n » 1) return n*fac(n-1); else return 1; *)
 Как и семантика передачи параметров, семантика возврата функцией значения идентична семантике инициализации. Возврщаемое значение рассматривается как инициализатор переменной возвращаемого типа. Тип возвращаемого выражения проверяется на согласованность с возвращаемым типом и выполняются все стандартные и определенные пользователем преобразования тпов. Например:
 double f() (* // ... return 1; // неявно преобразуется к double(1) *)
 Каждый раз, когда вызывается функция, создается новая копия ее параметров и автоматических переменных. После возрата из функции память используется заново, поэтому возврщать указатель на локальную переменную неразумно. Содержание указываемого места изменится непредсказуемо:
 int* f() (* int local = 1; // ... return amp;local; // так не делайте *)
 Эта ошибка менее обычна, чем эквивалентная ошибка при использовании ссылок:
 int amp; f() (* int local = 1; // ... return local; // так не делайте *)
 К счастью, о таких возвращаемых значениях предупреждает компилятор. Вот другой пример:
 int amp; f() (* return 1;*) // так не делайте




 4.6.5 Векторные Параметры


 Если в качестве параметра функции используется вектор, то передается указатель на его первый элемент. Например:
 int strlen(const char*);
 void f() (* char v[] = «a vector» strlen(v); strlen(«Nicholas»); *);
 Иначе говоря, при передаче как параметр параметр типа T[] преобразуется к T*. Следовательно, присваивание элементу векторного параметра изменяет значение элемента вектора, кторый является параметром. Другими словами, вектор отличается от всех остальных типов тем, что вектор не передается (и не может передаваться) по значению.
 Размер вектора недоступен вызываемой функции. Это может быть неудобно, но эту сложность можно обойти несколькими спсобами. Строки оканчиваются нулем, поэтому их размер можно легко вычислить. Для других векторов можно передавать второй
 параметр, который задает размер, или определить тип, содержщий указатель и индикатор длины, и передавать его вместо просто вектора (см. также #1.11). Например:
 void compute1(int* vec_ptr, int vec_size); // один способ
 struct vec (* // другой способ int* ptr; int size; *);
 void compute2(vec v);
 С многомерными массивами все хитрее, но часто можно вместо них использовать векторы указателей, которые не требют специального рассмотрения. Например:
 char* day[] = (* «mon», «tue», «wed», «thu», «fri», «sat», «sun» *);
 С другой стороны, рассмотрим определение функции, котрая работает с двумерными матрицами. Если размерность извесна на стадии компиляции, то никаких проблем нет:
 void print_m34(int m[3][4]) (* for (int i = 0; i«3; i++) (* for (int j = 0; j„4; j++) cout «« " " «« m[i][j]; cout «« «\n“; *) *)
 Матрица, конечно, все равно передается как указатель, а размерности используются просто для удобства записи.
 Первая размерность массива не имеет отношения к задаче поиска положения элемента (#2.3.6). Поэтому ее можно передвать как параметр:
 void print_mi4(int m[][4], int dim1) (* for (int i = 0; i«dim1; i++) (* for (int j = 0; j„4; j++) cout «« " " «« m[i][j]; cout «« «\n“; *) *)
 Сложный случай возникает, когда нужно передавать обе размерности. «Очевидное решение» просто не работает:
 void print_mij(int m[][], int dim1, int dim2) // ошибка (* for (int i = 0; i«dim1; i++) (* for (int j = 0; j„dim2; j++) cout «« " " «« m[i][j]; // сюрприз! cout «« «\n“; *) *)
 Во-первых, описание параметра m[][] недопустимо, покольку для нахождения положения элемента должна быть известна вторая размерность многомерного массива. Во-вторых, выражение m[i][j] интерпретируется (правильно) как *(*(m+i)+j), но нпохоже, чтобы это имел в виду программист. Вот правильное решение:
 void print_mij(int** m, int dim1, int dim2) (* for (int i = 0; i«dim1; i++) (* for (int j = 0; j„dim2; j++) cout «« " " «« (int*)m[i*dim2+j]; // туманно cout «« «\n“; *) *)
 Выражение, которое применяется для доступа к элементам, эквивалентно тому, которое генерирует компилятор, когда он знает последнюю размерность. Чтобы немного прояснить програму, можно ввести дополнительную переменную:
 int* v = (int*)m; // ... v[i*dim2+j]




 4.6.6 Параметры по Умолчанию


 Часто в самом общем случае функции требуется больше праметров, чем в самом простом и более употребительном случае. Например, в библиотеке потоков есть функция hex(), порождащая строку с шестнадцатиричным представлением целого. Второй параметр используется для задания числа символов для предтавления первого параметра. Если число символов слишком мало для представления целого, происходит усечение, если оно сликом велико, то строка дополняется пробелами. Часто програмист не заботится о числе символов, необходимых для предсталения целого, поскольку символов достаточно. Поэтому для нуля в качестве второго параметра определено значение «использвать столько символов, сколько нужно». Чтобы избежать засорния программы вызовами вроде hex(i,0), функция описывается так:
 extern char* hex(long, int =0);
 Инициализатор второго параметра является параметром по умолчанию. То есть, если в вызове дан только один параметр, в качестве второго используется параметр по умолчанию. Напрмер:
 cout «„ „**“ «« hex(31) «« hex(32,3) «« «**“;
 интерпретируется как
 cout «„ „**“ «« hex(31,0) «« hex(32,3) «« «**“;
 и напечатает:
 ** 1f 20**
 Параметр по умолчанию проходит проверку типа во время описания функции и вычисляется во время ее вызова. Задавать параметр по умолчанию возможно только для последних парамеров, поэтому
 int f(int, int =0, char* =0); // ok int g(int =0, int =0, char*); // ошибка int f(int =0, int, char* =0); // ошибка
 Заметьте, что в этом контексте пробел между * и = явлется существенным (*= является операцией присваивания):
 int nasty(char*=0); // синтаксическая ошибка




 4.6.7 Перегрузка Имен Функций


 Как правило, давать разным функциям разные имена – мысль хорошая, но когда некоторые функции выполняют одинаковую рботу над объектами разных типов, может быть более удобно дать им одно и то же имя. Использование одного имени для различных действий над различными типами называется перегрузкой (overloading). Метод уже используется для основных операций С ++: у сложения существует только одно имя, +, но его можно применять для сложения значений целых, плавающих и указателных типов. Эта идея легко расширяется на обработку операций, определенных пользователем, то есть, функций. Чтобы уберечь программиста от случайного повторного использования имени, имя может использоваться более чем для одной функции только если оно сперва описано как перегруженное имя функции. Напрмер:
 overload print; void print(int); void print(char*);
 Что касается компилятора, единственное общее, что имеют функции с одинаковым именем, это имя. Предположительно, они в каком-то смысле похожи, но в этом язык ни стесняет програмиста, ни помогает ему. Таким образом, перегруженные имена функций – это главным образом удобство записи. Это удобство значительно в случае функций с общепринятыми именами вроде sqrt, print и open. Когда имя семантически значимо, как это имеет место для операций вроде +, * и «« (#6.2) и в случае конструкторов (#5.2.4 и #6.3.1), это удобство становится сщественным. Когда вызывается перегруженная f(), компилятор должен понять, к какой из функций с именем f следует обртиться. Это делается путем сравнения типов фактических парметров с типами формальных параметров всех функций с именем f. Поиск функции, которую надо вызвать, осуществляется за три отдельных шага:
 1. Искать функцию соответствующую точно, и использовать ее, если она найдена,
 2. Искать соответствующую функцию используя встроенные преобразования и использовать любую найденную функцию и
 3. Искать соответствующую функцию используя преобразвания, определенные пользователем (#6.3), и если множество преобразований единственно, использовать найденную функцию.
 Например:
 overload print(double), print(int);
 void f(); (* print(1); print(1.0); *)
 Правило точного соответствия гарантирует, что f напечтает 1 как целое и 1.0 как число с плавающей точкой. Ноль, char или short точно соответствуют параметру. Аналогично, float точно соответствует double.
 К параметрам функций с перегруженными именами стандарные С++ правила неявного преобразования типа (#с.6.6) примняются не полностью. Преобразования, могущие уничтожить иформацию, не выполняются. Остаются int в long, int в double, ноль в long, ноль в double и преобразования указателей: преобразование ноль в указатель void*, и указатель на произвоный класс в указатель на базовый класс (#7.2.4).
 Вот пример, в котором преобразование необходимо:
 overload print(double), print(long);
 void f(int a); (* print(a); *)
 Здесь a может быть напечатано или как double, или как long. Неоднозначность разрешается явным преобразованием типа (или print(long(a)) или print(double(a))).
 При этих правилах можно гарантировать, что когда эффетивность или точность вычислений для используемых типов сщественно различаются, будет использоваться простейший алгритм (функция). Например:
 overload pow; int pow(int, int); double pow(double, double); // из «math.h» complex pow(double, complex); // из «complex.h» complex pow(complex, int); complex pow(complex, double); complex pow(complex, complex);
 Процесс поиска подходящей функции игнорирует unsigned и const.




 4.6.8 Незаданное Число Параметров


 Для некоторых функций невозможно задать число и тип всех параметров, которые можно ожидать в вызове. Такую функцию описывают завершая список описаний параметров многоточием (...), что означает «и может быть, еще какие-то неописанные параметры». Например:
 int printf(char* ...);
 Это задает, что в вызове printf должен быть по меньшей мере один параметр, char*, а остальные могут быть, а могут и не быть. Например:
 printf(«Hello, world\n»); printf(«Мое имя %s %s\n», first_name, second_name); printf(«%d + %d = %d\n»,2,3,5);
 Такая функция полагается на информацию, которая недотупна компилятору при интерпретации ее списка параметров. В случае printf() первым параметром является строка формата, содержащая специальные последовательности символов, позволящие printf() правильно обрабатывать остальные параметры. %s означает «жди параметра char*», а %d означает «жди параметра int». Однако, компилятор этого не знает, поэтому он не может убедиться в том, что ожидаемые параметры имеют соответствущий тип. Например: printf(«Мое имя %s %s\n»,2);
 откомпилируется и в лучшем случае приведет к какой-нбудь странного вида выдаче. Очевиднще хуже, каждый вызов функции с автоматическим объектом класса включает по меньшей мере один вызов программ выделения и освобождения свободной памяти. Это сделало бы также невозможным реализацию inline-функций членов, которые обращаются к данным закрытой части. Более того, такое изменение сделает невозможным совместную компоновку C и С++ программ (поскольку C компилятор обрабатывает struct не так, как это будет делать С++ компилятор). Для С++ это было сочтено неприемлемым.




 5.3.2 Законченный Класс


 Программирование без сокрытия данных (с применением структур) требует меньшей продуманности, чем программирование со сокрытием данных (с использованием классов). Структуру можно определить не слишком задумываясь о том, как ее предплагается использовать. А когда определяется класс, все внимние сосредотачивается на обеспечении нового типа полным мнжеством операций; это важное смещение акцента. Время, потраченное на разработку нового типа, обычно многократно окупается при разработке и тестировании программы.
 Вот пример законченного типа intset, который реализует понятие «множество целых»:
 class intset (* int cursize, maxsize; int *x; public: intset(int m, int n); // самое большее, m int'ов в 1..n ~intset();
 int member(int t); // является ли t элементом? void insert(int t); // добавить "t" в множество
 void iterate(int amp; i) (* i = 0; *) int ok(int amp; i) (* return i«cursize; *) int next(int amp; i) (* return x[i++]; *) *);
 Чтобы протестировать этот класс, можно создать и распчатать множество случайных целых чисел. Такое множество могло бы быть результатом розыгрыша лотереи. Это простое множество можно также использовать для проверки последовательности цлых на повторы. Но для большинства приложений тип множество должен быть немного более проработанным. Как всегда, возможны ошибки:
 #include «stream.h»
 void error(char* s) (* cerr «„ "set: " «« s «« «\n“; exit(1); *)
 Класс intset используется в main(), которая предполагает два целых параметра. Первый параметр задает число случайных чисел, которые нужно сгенерировать. Второй параметр указывает диапазон, в котором должны лежать случайные целые:
 main(int argc, char* argv[]) (* if (argc != 3) error(«ожидается два параметра»); int count = 0; int m = atoi(argv[1]); // число элементов множества int n = atoi(argv[2]); // в диапазоне 1..n intset s(m,n);
 while (count«m) (* int t = randint(n);
 if (s.member(t)==0) (* s.insert(t); count++; *) *)
 print_in_order( amp;s); *)
 В программе, для которой требуется два параметра, счечик числа параметров, argc, должен равняться трем, потому что имя программы всегда передается как argv[0]. Функция
 extern int atoi(char*);
 функция atoi() это стандартная библиотечная функция для преобразования представления целого в виде строки в его внуреннюю (двоичную) форму. Случайные числа генерируются с пмощью стандартной функции rand():
 extern int rand(); // Не очень случайные, будьте осторожны
 int randint(int u) // в диапазоне 1..u (* int r = rand(); if (r « 0) r = -r; return 1 + r%u ; *)
 Подробности реализации класса должны представлять для пользователя весьма незначительный интерес, но здесь в любом случае будут функции члены. Конструктор выделяет целый вектор заданного максимального размера множества, а деструктор освбождает его:
 intset::intset(int m, int n)//самое большее,m int'ов в 1..n (* if (m«1 !! n„m) error(«недопустимый размер intset“); cursize = 0; maxsize = m; x = new int[maxsize]; *)
 intset::~intset() (* delete x; *)
 Целые числа вставляются, поэтому они хранятся в возратающем порядке:
 void intset::insert(int t) (* if (++cursize » maxsize) error(«слишком много элементов»); int i = cursize-1; x[i] = t;
 while (i»0 amp; amp; x[i-1]»x[i]) (* int t = x[i]; // переставить x[i] и [i-1] x[i] = x[i-1]; x[i-1] = t; i–; *) *)
 Для нахождения членов используется просто двоичный писк:
 int intset::member(int t) // двоичный поиск (* int l = 0; int u = cursize-1;
 while (l «= u) (* int m = (l+u)/2; if (t „ x[m]) u = m-1; else if (t “ x[m]) l = m+1; else return 1; // найдено *) return 0; // не найдено *)
 И, наконец, нам нужно обеспечить множество операций, чтобы пользователь мог осуществлять цикл по множеству в нектором порядке, поскольку представление intset от пользователя скрыто. Множество внутренней упорядоченности не имеет, поэтму мы не можем просто дать возможность обращаться к вектору (завтра я, наверное, реализую intset по-другому, в виде свзанного списка).
 Дается три функции: iterate() для инициализации итерции, ok() для проверки, есть ли следующий элемент, и next() для того, чтобы взять следующий элемент:
 class intset (* // ... void iterate(int amp; i) (* i = 0; *) int ok(int amp; i) (* return i«cursize; *) int next(int amp; i) (* return x[i++]; *) *);
 Чтобы дать возможность этим трем операциям работать соместно и чтобы запомнить, куда дошел цикл, пользователь дожен дать целый параметр. Поскольку элементы хранятся в отсотированном списке, их реализация тривиальна. Теперь можно определить функцию печати по порядку print_in_order:
 void print_in_order(intset* set) (* int var; set-»iterate(var); while (set-»ok(var)) cout «„ set-“next(var) „« «\n“; *)
 Другой способ задать итератор приводится в #6.8.




 5.4 Друзья и Объединения


 В это разделе описываются еще некоторые особенности, ксающиеся классов. Показано, как предоставить функции не члену доступ к закрытым членам. Описывается, как разрешать конфлиты имен членов, как можно делать вложенные описания классов, и как избежать нежелательной вложенности. Обсуждается также, как объекты класса могут совместно использовать члены данные, и как использовать указатели на члены. Наконец, приводится пример, показывающий, как построить дискриминирующее (экононое) объединение.
  5.4.1 Друзья 
 Предположим, вы определили два класса, vector и matrix (вектор и матрица). Каждый скрывает свое представление и прдоставляет полный набор действий для манипуляции объектами его типа. Теперь определим функцию, умножающую матрицу на вектор. Для простоты допустим, что в векторе четыре элемента, которые индексируются 0...3, и что матрица состоит из четырех векторов, индексированных 0...3. Допустим также, что доступ к элементам вектора осуществляется через функцию elem(), котрая осуществляет проверку индекса, и что в matrix имеется аналогичная функция. Один подход состоит в определении глбальной функции multiply() (перемножить) примерно следующим образом:
 vector multiply(matrix amp; m, vector amp; v); (* vector r; for (int i = 0; i«3; i++) (* // r[i] = m[i] * v; r.elem(i) = 0; for (int j = 0; j«3; j++) r.elem(i) += m.elem(i,j) * v.elem(j); *) return r; *)
 Это своего рода «естественный» способ, но он очень неэфективен. При каждом обращении к multiply() elem() будет взываться 4*(1+4*3) раза.
 Теперь, если мы сделаем multiply() членом класса vector, мы сможем обойтись без проверки индексов при обращении к элменту вектора, а если мы сделаем multiply() членом класса matrix, то мы сможем обойтись без проверки индексов при обрщении к элементу матрицы. Однако членом двух классов функция быть не может. Нам нужно средство языка, предоставляющее функции право доступа к закрытой части класса. Функция не член, получившая право доступа к закрытой части класса, назвается другом класса (friend). Функция становится другом класса после описания как friend. Например:
 class matrix;
 class vector (* float v[4]; // ... friend vector multiply(matrix amp;, vector amp;); *);
 class matrix (* vector v[4]; // ... friend vector multiply(matrix amp;, vector amp;); *);
 Функция друг не имеет никаких особенностей, помимо права доступа к закрытой части класса. В частности, friend функция не имеет указателя this (если только она не является полноравным членом функцией). Описание friend – настоящее описние. Оно вводит имя функции в самой внешней области видимости программы и сопоставляется с другими описаниями этого имени. Описание друга может располагаться или в закрытой, или в отрытой части описания класса. Где именно, значения не имеет.
 Теперь можно написать функцию умножения, которая исползует элементы векторов и матрицы непосредственно:
 vector multiply(matrix amp; m, vector amp; v); (* vector r; for (int i = 0; i«3; i++) (* // r[i] = m[i] * v; r.v[i] = 0;
 for (int j = 0; j«3; j++) r.v[i] += m.v[i][j] * v.v[j]; *) return r; *)
 Есть способы преодолеть эту конкретную проблему эффетивности не используя аппарат friend (можно было бы определить операцию векторного умножения и определить multiply() с ее помощью). Однако существует много задач, кторые проще всего решаются, если есть возможность предоствить доступ к закрытой части класса функции, которая не явлется членом этого класса. В Главе 6 есть много примеров применения friend. Достоинства функций друзей и членов будут обсуждаться позже.
 Функция член одного класса может быть другом другого. Например:
 class x (* // ... void f(); *);
 class y (* // ... friend void x::f(); *);
 Нет ничего необычного в том, что все функции члены однго класса являются друзьями другого. Для этого есть даже блее краткая запись:
 class x (* friend class y; // ... *);
 Такое описание friend делает все функции члены класса y друзьями x.




 5.4.2 Уточнение* Имени Члена


 – * Иногда называется также квалификацией. (прим. перев.)
 Иногда полезно делать явное различие между именами члнов класса и прочими именами. Для этого используется операция ::, «разрешения области видимости»:
 class x (* int m; public: int readm() (* return x::m; *) void setm(int m) (* x::m = m; *) *);
 В x::setm() имя параметра m прячет член m, поэтому единственный способ сослаться на член – это использовать его уточненное имя x::m. Операнд в левой части :: должен быть именем класса.
 Имя с префиксом :: (просто) должно быть глобальным имнем. Это особенно полезно для того, чтобы можно было исползовать часто употребимые имена вроде read, put и open как имена функций членов, не теряя при этом возможности обращатся к той версии функции, которая не является членом. Например:
 class my_file (* // ... public: int open(char*, char*); *);
 int my_file::open(char* name, char* spec) (* // ... if (::open(name,flag))(*//использовать open() из UNIX(2) // ... *) // ... *)




 5.4.3 Вложенные Классы


 Описание класса может быть вложенным. Например:
 class set (* struct setmem (* int mem; setmem* next; setmem(int m, setmem* n) (* mem=m; next=n; *) *); setmem* first; public: set() (* first=0; *) insert(int m) (* first = new setmem(m,first);*) // ... *);
 Если только вложенный класс не является очень простым, в таком описании трудно разобраться. Кроме того, вложение класов – это не более чем соглашение о записи, поскольку вложеный класс не является скрытым в области видимости лексически охватывающего класса:
 class set (* struct setmem (* int mem; setmem* next; setmem(int m, setmem* n) *); // ... *);
 setmem::setmem(int m, setmem* n) (* mem=m, next=n*)
 setmem m1(1,0); Такая запись, как set::setmem::setmem(), не является ни необходимой, ни допустимой. Единственный способ скрыть имя класса – это сделать это с помощью метода файлы-как-модули (# 4.4). Большую часть нетривиальных классов лучше описывать раздельно:
 class setmem (* friend class set; // доступ только с помощью членов set int mem; setmem* next; setmem(int m, setmem* n) (* mem=m; next=n; *) *);
 class set (* setmem* first; public: set() (* first=0; *) insert(int m) (* first = new setmem(m,first);*) // ... *);




 5.4.4 Статические Члены


 Класс – это тип, а не объект данных, и в каждом объекте класса имеется своя собственная копия данных, членов этого класса. Однако некоторые типы наиболее элегантно реализуются, если все объекты этого типа могут совместно использовать (разделять) некоторые данные. Предпочтительно, чтобы такие разделяемые данные были описаны как часть класса. Например, для управления задачами в операционной системе или в ее модли часто бывает полезен список всех задач:
 class task (* // ... task* next; static task* task_chain; void shedule(int); void wait(event); // ... *);
 Описание члена task_chain (цепочка задач) как static обеспечивает, что он будет всего лишь один, а не по одной кпии на каждый объект task. Он все равно остается в области видимости класса task, и «извне» доступ к нему можно полчить, только если он был описан как public. В этом случае его имя должно уточняться именем его класса:
 task::task_chain
 В функции члене на него можно ссылаться просто task_chain. Использование статических членов класса может зметно снизить потребность в глобальных переменных.




 5.4.5 Указатели на Члены


 Можно брать адрес члена класса. Получение адреса функции члена часто бывает полезно, поскольку те цели и причины, кторые приводились в #4.6.9 относительно указателей на фунции, в равной степени применимы и к функциям членам. Однако, на настоящее время в языке имеется дефект: невозможно описать выражением тип указателя, который получается в результате этой операции. Поэтому в текущей реализации приходится жулничать, используя трюки. Что касается примера, который привдится ниже, то не гарантируется, что он будет работать. Ипользуемый трюк надо локализовать, чтобы программу можно было
 преобразовать с использованием соответствующей языковой контрукции, когда появится такая возможность. Этот трюк исползует тот факт, что в текущей реализации this реализуется как первый (скрытый) параметр функции члена*: – * Более поздние версии С++ поддерживают понятие указтель на член: cl::* означает «указатель на член класса cl». Например:
 typedef void (cl::*PROC)(int); PROC pf1 = amp;cl::print; // приведение к типу ненужно PROC pf2 = amp;cl::print;
 Для вызовов через указатель на функцию член используются операции . и -». Например:
 (z1.*pf1)(2); (( amp;z2)-»*pf2)(4);
 (прим. автора)
 #include «stream.h»
 struct cl (* char* val; void print(int x) (* cout «„ val «« x «« «\n“; *); cl(char* v) (* val = v; *) *);
 // ``фальшивый'' тип для функций членов: typedef void (*PROC)(void*, int);
 main() (* cl z1("z1 "); cl z2("z2 "); PROC pf1 = PROC( amp;z1.print); PROC pf2 = PROC( amp;z2.print); z1.print(1); (*pf1)( amp;z1,2); z2.print(3); (*pf2)( amp;z2,4); *)
 Во многих случаях можно воспользоваться виртуальными функциями (см. Главу 7) там, где иначе пришлось бы использвать указатели на функции.




 5.4.6 Структуры и Объединения


 По определению struct – это просто класс, все члены кторого открытые, то есть
 struct s (* ...
 есть просто сокращенная запись
 class s (* public: ...
 Структуры используются в тех случаях, когда сокрытие данных неуместно.
 Именованное объединение определяется как struct, в котрой все члены имеют один и тот же адрес (см. #с.8.5.13). Если известно, что в каждый момент времени нужно только одно знчение из структуры, то объединение может сэкономить пространство. Например, можно определить объединение для хранения лексических символов C компилятора: union tok_val (* char* p; // строка char v[8]; // идентификатор (максимум 8 char) long i; // целые значения double d; // значения с плавающей точкой *);
 Сложность состоит в том, что компилятор, вообще говоря, не знает, какой член используется в каждый данный момент, пэтому надлежащая проверка типа невозможна. Например:
 void strange(int i) (* tok_val x; if (i) x.p = "2"; else x.d = 2; sqrt(x.d); // ошибка если i != 0 *)
 Кроме того, объединение, определенное так, как это, нельзя инициализировать. Например:
 Глава 5 Классы
 Эти типы не «абстрактны», они столь же реальны, как int и float. – Дуг МакИлрой
 В этой главе описываются возможности определения новых типов в С++, для которых доступ к данным ограничен заданным множеством функций доступа. Объясняются способы защиты струтуры данных, ее инициализации, доступа к ней и, наконец, ее уничтожения. Примеры содержат простые классы для работы с таблицей имен, манипуляции стеком, работу с множеством и релизацию дискриминирующего (то есть, «надежного») объединения. Две следующие главы дополнят описание возможностей определния новых типов в С++ и познакомят читателя еще с некоторыми интересными примерами.




 5.1 Знакомство и Краткий Обзор


 Предназначение понятия класса, которому посвящены эта и две последующие главы, состоит в том, чтобы предоставить программисту инструмент для создания новых типов, столь же удобных в обращении сколь и встроенные типы. В идеале тип оределяемый пользователем, способом использования должен отлчаться от встроенных типов, только способом создания.
 Тип есть конкретное представление некоторой концепции (понятия). Например, имеющийся в С++ тип float с его операцями +, -, * и т.д. обеспечивает ограниченную, но конкретную версию математического понятия действительного числа. Новый тип создается для того, чтобы дать специальное и конкретное определение понятия, которому ничто прямо и очевидно среди встроенных типов не отвечает. Например, в программе, которая работает с телефоном, можно было бы создать тип trunk_module (элемент линии), а в программе обработки текстов – тип list_of_paragraphs (список параграфов). Как правило, програму, в которой создаются типы, хорошо отвечающие понятиям прложения, понять легче, чем программу, в которой это не делется. Хорошо выбранные типы, определяемые пользователем, делают программу более четкой и короткой. Это также позволяет компилятору обнаруживать недопустимые использования объектов, которые в противном случае останутся необнаруженными до тетирования программы.
 В определении нового типа основная идея – отделить несщественные подробности реализации (например, формат данных, которые используются для хранения объекта типа) от тех кчеств, которые существенны для его правильного использования (например, полный список функций, которые имеют доступ к даным). Такое разделение можно описать так, что работа со структурой данных и внутренними административными подпрограмами осуществляется через специальный интерфейс (канализирется).
 Эта глава состоит из четырех практически отдельных чатей:
 #5.2 Классы и Члены. Этот раздел знакомит с основным понятием типа, определяемого пользователем, который называеся класс (class). Доступ к объектам класса может ограничваться набором функций, которые описаны как часть этого класа. Такие функции называются функциями членами. Объекты класса создаются и инициализируются функциями членами, спецально для этой цели описанными. Эти функции называются контрукторами. Функция член может быть специальным образом опсана для «очистки» каждого классового объекта при его уничтожении. Такая функция называется деструктором.
 #5.3 Интерфейсы и Реализации. В этом разделе приводится два примера того, как класс проектируется, реализуется и ипользуется.
 #5.4 Друзья и Объединения. В этом разделе приводится много дополнительных подробностей, касающихся классов. В нем показано, как предоставить доступ к закрытой части класса функции, которая не является членом этого класса. Такая фунция называется друг (friend). В этом разделе показано также, как определить дискриминирующее объединение.
 #5.5 Конструкторы и Деструкторы. Объект может создаватся как автоматический, статический или как объект в свободной памяти. Объект может также быть членом некоторой совокупности (типа вектора или класса), которая в свою очередь может рамещаться одним из этих трех способов. Довольно подробно обясняется использование конструкторов и деструкторов.




 5.2 Классы и Члены


 Класс – это определяемый пользователем тип. Этот раздел знакомит с основными средствами определения класса, создания объекта класса, работы с такими объектами и, наконец, уничтжения таких объектов после использования.




 5.2.1 Функции Члены


 Рассмотрим реализацию понятия даты с использованием struct для того, чтобы определить представление даты date и множества функций для работы с переменными этого типа:
 struct date (* int month, day, year; *); // дата: месяц, день, год *) date today; void set_date(date*, int, int, int); void next_date(date*); void print_date(date*); // ...
 Никакой явной связи между функциями и типом данных нет. Такую связь можно установить, описав функции как члены:
 struct date (* int month, day, year;
 void set(int, int, int); void get(int*, int*, int*); void next(); void print(); *);
 Функции, описанные таким образом, называются функциями членами и могут вызываться только для специальной переменной соответствующего типа с использованием стандартного синтаксса для доступа к членам структуры. Например:
 date today; // сегодня date my_burthday; // мой день рождения
 void f() (* my_burthday.set(30,12,1950); today.set(18,1,1985);
 my_burthday.print();
 today.next(); *)
 Поскольку разные структуры могут иметь функции члены с одинаковыми именами, при определении функции члена необходимо указывать имя структуры:
 void date::next() (* if ( ++day » 28 ) (* // делает сложную часть работы *) *)
 В функции члене имена членов могут использоваться без явной ссылки на объект. В этом случае имя относится к члену того объекта, для которого функция была вызвана.




 5.2.2 Классы


 Описание date в предыдущем подразделе дает множество функций для работы с date, но не указывает, что эти функции должны быть единственными для доступа к объектам типа date. Это ограничение можно наложить используя вместо struct class:
 class date (* int month, day, year; public: void set(int, int, int); void get(int*, int*, int*); void next(); void print(); *);
 Метка public: делит тело класса на две части. Имена в первой, закрытой части, могут использоваться только функциями членами. Вторая, открытая часть, составляет интерфейс к обекту класса. Struct – это просто class, у которого все члены классы открытые, поэтому функции члены определяются и исползуются точно так же, как в предыдущем случае. Например:
 void date::ptinr() // печатает в записи, принятой в США (* cout «« month «« "/" «« day «« "/" year; *)
 Однако функции не члены отгорожены от использования зарытых членов класса date. Например:
 void backdate() (* today.day–; // ошибка *)
 В том, что доступ к структуре данных ограничен явно опсанным списком функций, есть несколько преимуществ. Любая ошибка, которая приводит к тому, что дата принимает недопутимое значение (например, Декабрь 36, 1985) должна быть вывана кодом функции члена, поэтому первая стадия отладки, лкализация, выполняется еще до того, как программа будет запущена. Это частный случай общего утверждения, что любое изменение в поведении типа date может и должно вызываться именениями в его членах. Другое преимущество – это то, что птенциальному пользователю такого типа нужно будет только унать определение функций членов, чтобы научиться им пользоваться.
 Защита закрытых данных связана с ограничением использвания имен членов класса. Это можно обойти с помощью манипляции адресами, но это уже, конечно, жульничество.




 5.2.3 Ссылки на Себя


 В функции члене на члены объекта, для которого она была вызвана, можно ссылаться непосредственно. Например:
 class x (* int m; public: int readm() (* return m; *) *);
 x aa; x bb;
 void f() (* int a = aa.readm(); int b = bb.readm(); // ... *)
 В первом вызове члена member() m относится к aa.m, а во втором – к bb.m.
 Указатель на объект, для которого вызвана функция член, является скрытым параметром функции. На этот неявный параметр можно ссылаться явно как на this. В каждой функции класса x указатель this неявно описан как
 x* this;
 и инициализирован так, что он указывает на объект, для которого была вызвана функция член. this не может быть описан явно, так как это ключевое слово. Класс x можно эквивалентным образом описать так:
 class x (* int m; public: int readm() (* return this-»m; *) *);
 При ссылке на члены использование this излишне. Главным образом this используется при написании функций членов, котрые манипулируют непосредственно указателями. Типичный пример этого – функция, вставляющая звено в дважды связанный список:
 class dlink (* dlink* pre; // предшествующий dlink* suc; // следующий public: void append(dlink*); // ... *);
 void dlink::append(dlink* p) (* p-»suc = suc; // то есть, p-»suc = this-»suc p-»pre = this; // явное использование this suc-»pre = p; // то есть, this-»suc-»pre = p suc = p; // то есть, this-»suc = p *)
 dlink* list_head;
 void f(dlink*a, dlink *b) (* // ... list_head-»append(a); list_head-»append(b); *)
 Цепочки такой общей природы являются основой для списквых классов, которые описываются в Главе 7. Чтобы присоеднить звено к списку необходимо обновить объекты, на которые указывают указатели this, pre и suc (текущий, предыдущий и последующий). Все они типа dlink, поэтому функция член dlink::append() имеет к ним доступ. Единицей защиты в С++ яляется class, а не отдельный объект класса.




 5.2.4 Инициализация


 Использование для обеспечения инициализации объекта класса функций вроде set_date() (установить дату) неэлегантно и чревато ошибками. Поскольку нигде не утверждается, что обект должен быть инициализирован, то программист может забыть это сделать, или (что приводит, как правило, к столь же рарушительным последствиям) сделать это дважды. Есть более хроший подход: дать возможность программисту описать функцию, явно предназначенную для инициализации объектов. Поскольку такая функция конструирует значения данного типа, она назывется конструктором. Конструктор распознается по тому, что имеет то же имя, что и сам класс. Например:
 class date (* // ... date(int, int, int); *);
 Когда класс имеет конструктор, все объекты этого класса будут инициализироваться. Если для конструктора нужны парметры, они должны даваться:
 date today = date(23,6,1983); date xmas(25,12,0); // сокращенная форма // (xmas – рождество) date my_burthday; // недопустимо,опущена инициализация
 Часто бывает хорошо обеспечить несколько способов иницализации объекта класса. Это можно сделать, задав несколько конструкторов. Например:
 class date (* int month, day, year; public: // ... date(int, int, int); // день месяц год date(char*); // дата в строковом представлении date(int); // день, месяц и год сегодняшние date(); // дата по умолчанию: сегодня *);
 Конструкторы подчиняются тем же правилам относительно типов параметров, что и перегруженные функции (#4.6.7). Если конструкторы существенно различаются по типам своих парамеров, то компилятор при каждом использовании может выбрать правильный:
 date today(4); date july4(«Июль 4, 1983»); date guy(«5 Ноя»); date now; // инициализируется по умолчанию
 Заметьте, что функции члены могут быть перегружены без явного использования ключевого слова overload. Поскольку поный список функций членов находится в описании класса и как правило короткий, то нет никакой серьезной причины требовать использования слова overload для предотвращения случайного повторного использования имени.
 Размножение конструкторов в примере с date типично. При разработке класса всегда есть соблазн обеспечить «все», покольку кажется проще обеспечить какое-нибудь средство просто на случай, что оно кому-то понадобится или потому, что оно изящно выглядит, чем решить, что же нужно на самом деле. Поледнее требует больших размышлений, но обычно приводит к программам, которые меньше по размеру и более понятны. Один из способов сократить число родственных функций – использвать параметры со значением по умолчанию, пример. В случае date для каждого параметра можно задать значение по умолчнию, интерпретируемое как «по умолчанию принимать: today» (сегодня).
 class date (* int month, day, year; public: // ... date(int d =0, int m =0, int y =0); date(char*); // дата в строковом представлении *);
 date::date(int d, int m, int y) (* day = d ? d : today.day; month = m ? m : today.month; year = y ? y : today.year; // проверка, что дата допустимая // ... *)
 Когда используется значение параметра, указывающее «брать по умолчанию», выбранное значение должно лежать вне множества возможных значений параметра. Для дня day и месяца mounth ясно, что это так, но для года year выбор нуля неочвиден. К счастью, в европейском календаре нет нулевого года . Сразу после 1 г. до н.э. (year==-1) идет 1 г. н.э. (year==1), но для реальной программы это может оказаться слишком тонко.
 Объект класса без конструкторов можно инициализировать путем присваивания ему другого объекта этого класса. Это моно делать и тогда, когда конструкторы описаны. Например:
 date d = today; // инициализация посредством присваивания
 По существу, имеется конструктор по умолчанию, опредленный как побитовая копия объекта того же класса. Если для класса X такой конструктор по умолчанию нежелателен, его моно переопределить конструктором с именем X(X amp;). Это будет осуждаться в #6.6.




 5.2.5 Очистка


 Определяемый пользователем тип чаще имеет, чем не имеет, конструктор, который обеспечивает надлежащую инициализацию. Для многих типов также требуется обратное действие, деструктор, чтобы обеспечить соответствующую очистку объектов этого типа. Имя деструктора для класса X есть ~X() («дополнение конструктора»). В частности, многие типы используют некоторый объем памяти из свободной памяти (см. #3.2.6), который выдляется конструктором и освобождается деструктором. Вот, наример, традиционный стековый тип, из которого для краткости полностью выброшена обработка ошибок:
 class char_stack (* int size; char* top; char* s; public: char_stack(int sz) (* top=s=new char[size=sz]; *) ~char_stack() (* delete s; *) // деструктор void push(char c) (* *top++ = c; *) char pop() (* return *–top;*) *)
 Когда char_stack выходит из области видимости, вызываеся деструктор:
 void f() (* char_stack s1(100); char_stack s2(200); s1.push('a'); s2.push(s1.pop()); char ch = s2.pop(); cout «„ chr(ch) «« «\n“; *)
 Когда вызывается f(), конструктор char_stack вызывается для s1, чтобы выделить вектор из 100 символов, и для s2, чтбы выделить вектор из 200 символов. При возврате из f() эти два вектора будут освобождены.




 5.2.6 Inline


 При программировании с использованием классов очень чато используется много маленьких функций. По сути, везде, где в программе традиционной структуры стояло бы просто какое-нбудь обычное использование структуры данных, дается функция. То, что было соглашением, стало стандартом, который распознет компилятор. Это может страшно понизить эффективность, птому что стоимость вызова функции (хотя и вовсе не высокая по сравнению с другими языками) все равно намного выше, чем пара ссылок по памяти, необходимая для тела функции.
 Чтобы справиться с этой проблемой, был разработан аппрат inline-функций. Функция, определенная (а не просто опсанная) в описании класса, считается inline. Это значит, наример, что в функциях, которые используют приведенные выше char_stack, нет никаких вызовов функций кроме тех, которые используются для реализации операций вывода! Другими словами, нет никаких затрат времени выполнения, которые стоит принмать во внимание при разработке класса. Любое, даже самое мленькое действие, можно задать эффективно. Это утверждение снимает аргумент, который чаще всего приводят чаще всего в пользу открытых членов данных.
 Функцию член можно также описать как inline вне описания класса. Например: char char_stack (* int size; char* top;
 char* s; public: char pop(); // ... *);
 inline char char_stack::pop() (* return *–top; *)




 5.3 Интерфейсы и Реализации


 Что представляет собой хороший класс? Нечто, имеющее нбольшое и хорошо определенное множество действий. Нечто, что можно рассматривать как «черный ящик», которым манипулируют только посредством этого множества действий. Нечто, чье фатическое представление можно любым мыслимым способом измнить, не повлияв на способ использования множества действий. Нечто, чего можно хотеть иметь больше одного.
 Для всех видов контейнеров существуют очевидные примеры: таблицы, множества, списки, вектора, словари и т.д. Такой класс имеет операцию «вставить», обычно он также имеет оперции для проверки того, был ли вставлен данный элемент. В нем могут быть действия для осуществления проверки всех элементов в определенном порядке, и кроме всего прочего, в нем может иметься операция для удаления элемента. Обычно контейнерные (то есть, вмещающие) классы имеют конструкторы и деструкторы.
 Сокрытие данных и продуманный интерфейс может дать коцепция модуля (см. например #4.4: файлы как модули). Класс, однако, является типом. Чтобы использовать его, необходимо создать объекты этого класса, и таких объектов можно создвать столько, сколько нужно. Модуль же сам является объектом. Чтобы использовать его, его надо только инициализировать, и таких объектов ровно один.




 5.3.1 Альтернативные Реализации


 Пока описание открытой части класса и описание функций членов остаются неизменными, реализацию класса можно модифцировать не влияя на ее пользователей. Как пример этого расмотрим таблицу имен, которая использовалась в настольном калькуляторе в Главе 3. Это таблица имен:
 struct name (* char* string; char* next; double value; *);
 Вот вариант класса table:
 // файл table.h
 class table (* name* tbl; public: table() (* tbl = 0; *)
 name* look(char*, int = 0); name* insert(char* s) (* return look(s,1); *) *);
 Эта таблица отличается от той, которая определена в Глве 3 тем, что это настоящий тип. Можно описать более чем одну
 table, можно иметь указатель на table и т.д. Например:
 #include «table.h»
 table globals; table keywords; table* locals;
 main() (* locals = new table; // ... *)
 Вот реализация table::look(), которая использует линеный поиск в связанном списке имен name в таблице:
 #include «string.h»
 name* table::look(char* p, int ins) (* for (name* n = tbl; n; n=n-»next) if (strcmp(p,n-»string) == 0) return n;
 if (ins == 0) error(«имя не найдено»);
 name* nn = new name; nn-»string = new char[strlen(p)+1]; strcpy(nn-»string,p); nn-»value = 1; nn-»next = tbl; tbl = nn; return nn; *)
 Теперь рассмотрим класс table, усовершенствованный таким образом, чтобы использовать хэшированный просмотр, как это делалось в примере с настольным калькулятором. Сделать это труднее из-за того ограничения, что уже написанные программы, в которых использовалась только что определенная версия класа table, должны оставаться верными без изменений:
 class table (* name** tbl; int size; public: table(int sz = 15); ~table();
 name* look(char*, int = 0); name* insert(char* s) (* return look(s,1); *) *);
 В структуру данных и конструктор внесены изменения, оражающие необходимость того, что при использовании хэшировния таблица должна иметь определенный размер. Задание конструктора с параметром по умолчанию обеспечивает, что страя программа, в которой не указывался размер таблицы, остнется правильной. Параметры по умолчанию очень полезны в стуации, когда нужно изменить класс не повлияв на старые программы. Теперь конструктор и деструктор создают и уничтжают хэш-таблицы:
 table::table(int sz) (* if (sz « 0) error(„отрицательный размер таблицы“); tbl = new name*[size=sz];
 for (int i = 0; i«sz; i++) tbl[i] = 0; *)
 table::~table() (* for (int i = 0; i«size; i++) for (name* n = tbl[i]; n; n=n-»next) (* delete n-»string; delete n; *) delete tbl; *)
 Описав деструктор для класса name можно получить более простой и ясный вариант table::~table(). Функция просмотра практически идентична той, которая использовалась в примере настольного калькулятора (#3.1.3):
 #include «string.h»
 name* table::look(char* p, int ins) (* int ii = 0; char* pp = p; while (*pp) ii = ii««1 ^ *pp++; if (ii « 0) ii = -ii; ii %= size;
 for (name* n=tbl[ii]; n; n=n-»next) if (strcmp(p,n-»string) == 0) return n;
 if (ins == 0) error(«имя не найдено»);
 name* nn = new name; nn-»string = new char[strlen(p)+1]; strcpy(nn-»string,p); nn-»value = 1; nn-»next = tbl[ii]; tbl[ii] = nn; return nn;
 *)
 Очевидно, что функции члены класса должны заново комплироваться всегда, когда вносится какое-либо изменение в опсание класса. В идеале такое изменение никак не должно отржаться на пользователях класса. К сожалению, это не так. Для размещения переменной классового типа компилятор должен знать размер объекта класса. Если размер этих объектов меняется, то файлы, в которых класс используется, нужно компилировать зново. Можно написать такую программу (и она уже написана), которая определяет множество (минимальное) файлов, которое необходимо компилировать заново после изменения описания класса, но пока что широкого распространения она не получила.
 Почему, можете вы спросить, С++ разработан так, что поле изменения закрытой части необходима новая компиляция ползователей класса? И действительно, почему вообще закрытая часть должна быть представлена в описании класса? Другими словами, раз пользователям класса не разрешается обращаться к закрытым членам, почему их описания должны приводиться в зголовочных файлах, которые, как предполагается, пользователь читает? Ответ – эффективность. Во многих системах и процесс компиляции, и последовательность операций, реализующих вызов функции, проще, когда размер автоматических объектов (объетов в стеке) известен во время компиляции.
 Этой сложности можно избежать, представив каждый объект класса как указатель на «настоящий» объект. Так как все эти указатели будут иметь одинаковый размер, а размещение «настящих» объектов можно определить в файле, где доступна закртая часть, то это может решить проблему. Однако решение поразумевает дополнительные ссылки по памяти при обращении к членам класса, а также, что еще хуже, каждый вызов функции с автоматическим объектом класса включает по меньшей мере один вызов программ выделения и освобождения свободной памяти. Это сделало бы также невозможным реализацию inline-функций члнов, которые обращаются к данным закрытой части. Более того, такое изменение сделает невозможным совместную компоновку C и С++ программ (поскольку C компилятор обрабатывает struct не так, как это будет делать С++ компилятор). Для С++ это было сочтено неприемлемым.




 5.3.2 Законченный Класс


 Программирование без сокрытия данных (с применением структур) требует меньшей продуманности, чем программирование со сокрытием данных (с использованием классов). Структуру можно определить не слишком задумываясь о том, как ее предплагается использовать. А когда определяется класс, все внимние сосредотачивается на обеспечении нового типа полным мнжеством операций; это важное смещение акцента. Время, потраченное на разработку нового типа, обычно многократно окупается при разработке и тестировании программы.
 Вот пример законченного типа intset, который реализует понятие «множество целых»:
 class intset (* int cursize, maxsize; int *x; public: intset(int m, int n); // самое большее, m int'ов в 1..n ~intset();
 int member(int t); // является ли t элементом? void insert(int t); // добавить "t" в множество
 void iterate(int amp; i) (* i = 0; *) int ok(int amp; i) (* return i«cursize; *) int next(int amp; i) (* return x[i++]; *) *);
 Чтобы протестировать этот класс, можно создать и распчатать множество случайных целых чисел. Такое множество могло бы быть результатом розыгрыша лотереи. Это простое множество можно также использовать для проверки последовательности цлых на повторы. Но для большинства приложений тип множество должен быть немного более проработанным. Как всегда, возможны ошибки:
 #include «stream.h»
 void error(char* s) (* cerr «„ "set: " «« s «« «\n“; exit(1); *)
 Класс intset используется в main(), которая предполагает два целых параметра. Первый параметр задает число случайных чисел, которые нужно сгенерировать. Второй параметр указывает диапазон, в котором должны лежать случайные целые:
 main(int argc, char* argv[]) (* if (argc != 3) error(«ожидается два параметра»); int count = 0; int m = atoi(argv[1]); // число элементов множества int n = atoi(argv[2]); // в диапазоне 1..n intset s(m,n);
 while (count«m) (* int t = randint(n); if (s.member(t)==0) (* s.insert(t); count++; *) *)
 print_in_order( amp;s); *)
 В программе, для которой требуется два параметра, счечик числа параметров, argc, должен равняться трем, потому что имя программы всегда передается как argv[0]. Функция
 extern int atoi(char*);
 функция atoi() это стандартная библиотечная функция для преобразования представления целого в виде строки в его внуреннюю (двоичную) форму. Случайные числа генерируются с пмощью стандартной функции rand():
 extern int rand(); // Не очень случайные, будьте осторожны
 int randint(int u) // в диапазоне 1..u (* int r = rand(); if (r « 0) r = -r; return 1 + r%u ; *)
 Подробности реализации класса должны представлять для пользователя весьма незначительный интерес, но здесь в любом случае будут функции члены. Конструктор выделяет целый вектор заданного максимального размера множества, а деструктор освбождает его:
 intset::intset(int m, int n)//самое большее,m int'ов в 1..n (* if (m«1 !! n„m) error(«недопустимый размер intset“); cursize = 0; maxsize = m; x = new int[maxsize]; *)
 intset::~intset() (* delete x; *)
 Целые числа вставляются, поэтому они хранятся в возратающем порядке:
 void intset::insert(int t) (* if (++cursize » maxsize) error(«слишком много элементов»); int i = cursize-1; x[i] = t;
 while (i»0 amp; amp; x[i-1]»x[i]) (* int t = x[i]; // переставить x[i] и [i-1] x[i] = x[i-1]; x[i-1] = t; i–; *) *)
 Для нахождения членов используется просто двоичный писк:
 int intset::member(int t) // двоичный поиск (* int l = 0; int u = cursize-1;
 while (l «= u) (* int m = (l+u)/2; if (t „ x[m]) u = m-1; else if (t “ x[m]) l = m+1; else return 1; // найдено *) return 0; // не найдено *)
 И, наконец, нам нужно обеспечить множество операций, чтобы пользователь мог осуществлять цикл по множеству в нектором порядке, поскольку представление intset от пользователя скрыто. Множество внутренней упорядоченности не имеет, поэтму мы не можем просто дать возможность обращаться к вектору (завтра я, наверное, реализую intset по-другому, в виде свзанного списка).
 Дается три функции: iterate() для инициализации итерции, ok() для проверки, есть ли следующий элемент, и next() для того, чтобы взять следующий элемент:
 class intset (* // ... void iterate(int amp; i) (* i = 0; *) int ok(int amp; i) (* return i«cursize; *) int next(int amp; i) (* return x[i++]; *) *);
 Чтобы дать возможность этим трем операциям работать соместно и чтобы запомнить, куда дошел цикл, пользователь дожен дать целый параметр. Поскольку элементы хранятся в отсотированном списке, их реализация тривиальна. Теперь можно определить функцию печати по порядку print_in_order:
 void print_in_order(intset* set) (* int var; set-»iterate(var); while (set-»ok(var)) cout «„ set-“next(var) „« «\n“; *)
 Другой способ задать итератор приводится в #6.8.




 5.4 Друзья и Объединения


 В это разделе описываются еще некоторые особенности, ксающиеся классов. Показано, как предоставить функции не члену доступ к закрытым членам. Описывается, как разрешать конфликты имен членов, как можно делать вложенные описания классов, и как избежать нежелательной вложенности. Обсуждается также, как объекты класса могут совместно использовать члены данные, и как использовать указатели на члены. Наконец, приводится пример, показывающий, как построить дискриминирующее (экононое) объединение.




 5.4.1 Друзья


 Предположим, вы определили два класса, vector и matrix (вектор и матрица). Каждый скрывает свое представление и прдоставляет полный набор действий для манипуляции объектами его типа. Теперь определим функцию, умножающую матрицу на вектор. Для простоты допустим, что в векторе четыре элемента, которые индексируются 0...3, и что матрица состоит из четырех векторов, индексированных 0...3. Допустим также, что доступ к элементам вектора осуществляется через функцию elem(), котрая осуществляет проверку индекса, и что в matrix имеется аналогичная функция. Один подход состоит в определении глбальной функции multiply() (перемножить) примерно следующим образом:
 vector multiply(matrix amp; m, vector amp; v); (* vector r; for (int i = 0; i«3; i++) (* // r[i] = m[i] * v; r.elem(i) = 0; for (int j = 0; j«3; j++) r.elem(i) += m.elem(i,j) * v.elem(j); *) return r; *)
 Это своего рода «естественный» способ, но он очень неэфективен. При каждом обращении к multiply() elem() будет взываться 4*(1+4*3) раза.
 Теперь, если мы сделаем multiply() членом класса vector, мы сможем обойтись без проверки индексов при обращении к элменту вектора, а если мы сделаем multiply() членом класса matrix, то мы сможем обойтись без проверки индексов при обрщении к элементу матрицы. Однако членом двух классов функция быть не может. Нам нужно средство языка, предоставляющее функции право доступа к закрытой части класса. Функция не член, получившая право доступа к закрытой части класса, назвается другом класса (friend). Функция становится другом класса после описания как friend. Например:
 class matrix;
 class vector (* float v[4]; // ... friend vector multiply(matrix amp;, vector amp;); *);
 class matrix (* vector v[4]; // ... friend vector multiply(matrix amp;, vector amp;); *);
 Функция друг не имеет никаких особенностей, помимо права доступа к закрытой части класса. В частности, friend функция не имеет указателя this (если только она не является полноравным членом функцией). Описание friend – настоящее описние. Оно вводит имя функции в самой внешней области видимости
 программы и сопоставляется с другими описаниями этого имени. Описание друга может располагаться или в закрытой, или в отрытой части описания класса. Где именно, значения не имеет.
 Теперь можно написать функцию умножения, которая исползует элементы векторов и матрицы непосредственно:
 vector multiply(matrix amp; m, vector amp; v); (* vector r; for (int i = 0; i«3; i++) (* // r[i] = m[i] * v; r.v[i] = 0; for (int j = 0; j«3; j++) r.v[i] += m.v[i][j] * v.v[j]; *) return r; *)
 Есть способы преодолеть эту конкретную проблему эффетивности не используя аппарат friend (можно было бы определить операцию векторного умножения и определить multiply() с ее помощью). Однако существует много задач, кторые проще всего решаются, если есть возможность предоствить доступ к закрытой части класса функции, которая не явлется членом этого класса. В Главе 6 есть много примеров применения friend. Достоинства функций друзей и членов будут обсуждаться позже.
 Функция член одного класса может быть другом другого. Например:
 class x (* // ... void f(); *);
 class y (* // ... friend void x::f(); *);
 Нет ничего необычного в том, что все функции члены однго класса являются друзьями другого. Для этого есть даже блее краткая запись:
 class x (* friend class y; // ... *);
 Такое описание friend делает все функции члены класса y друзьями x.




 5.4.2 Уточнение* Имени Члена


 – * Иногда называется также квалификацией. (прим. перев.)
 Иногда полезно делать явное различие между именами члнов класса и прочими именами. Для этого используется операция ::, «разрешения области видимости»:
 class x (* int m; public: int readm() (* return x::m; *) void setm(int m) (* x::m = m; *)
 *);
 В x::setm() имя параметра m прячет член m, поэтому единственный способ сослаться на член – это использовать его уточненное имя x::m. Операнд в левой части :: должен быть именем класса.
 Имя с префиксом :: (просто) должно быть глобальным имнем. Это особенно полезно для того, чтобы можно было исползовать часто употребимые имена вроде read, put и open как имена функций членов, не теряя при этом возможности обращатся к той версии функции, которая не является членом. Например:
 class my_file (* // ... public: int open(char*, char*); *);
 int my_file::open(char* name, char* spec) (* // ... if (::open(name,flag))(*//использовать open() из UNIX(2) // ... *) // ... *)




 5.4.3 Вложенные Классы


 Описание класса может быть вложенным. Например:
 class set (* struct setmem (* int mem; setmem* next; setmem(int m, setmem* n) (* mem=m; next=n; *) *); setmem* first; public: set() (* first=0; *) insert(int m) (* first = new setmem(m,first);*) // ... *);
 Если только вложенный класс не является очень простым, в таком описании трудно разобраться. Кроме того, вложение класов – это не более чем соглашение о записи, поскольку вложеный класс не является скрытым в области видимости лексически охватывающего класса:
 class set (* struct setmem (* int mem; setmem* next; setmem(int m, setmem* n) *); // ... *);
 setmem::setmem(int m, setmem* n) (* mem=m, next=n*) setmem m1(1,0);
 Такая запись, как set::setmem::setmem(), не является ни необходимой, ни допустимой. Единственный способ скрыть имя класса – это сделать это с помощью метода файлы-как-модули (#
 4.4). Большую часть нетривиальных классов лучше описывать раздельно:
 class setmem (* friend class set; // доступ только с помощью членов set int mem; setmem* next; setmem(int m, setmem* n) (* mem=m; next=n; *) *);
 class set (* setmem* first; public: set() (* first=0; *) insert(int m) (* first = new setmem(m,first);*) // ... *);




 5.4.4 Статические Члены


 Класс – это тип, а не объект данных, и в каждом объекте класса имеется своя собственная копия данных, членов этого класса. Однако некоторые типы наиболее элегантно реализуются, если все объекты этого типа могут совместно использовать (разделять) некоторые данные. Предпочтительно, чтобы такие разделяемые данные были описаны как часть класса. Например, для управления задачами в операционной системе или в ее модли часто бывает полезен список всех задач:
 class task (* // ... task* next; static task* task_chain; void shedule(int); void wait(event); // ... *);
 Описание члена task_chain (цепочка задач) как static обеспечивает, что он будет всего лишь один, а не по одной кпии на каждый объект task. Он все равно остается в области видимости класса task, и «извне» доступ к нему можно полчить, только если он был описан как public. В этом случае его имя должно уточняться именем его класса:
 task::task_chain
 В функции члене на него можно ссылаться просто task_chain. Использование статических членов класса может зметно снизить потребность в глобальных переменных.




 5.4.5 Указатели на Члены


 Можно брать адрес члена класса. Получение адреса функции члена часто бывает полезно, поскольку те цели и причины, кторые приводились в #4.6.9 относительно указателей на фунции, в равной степени применимы и к функциям членам. Однако, на настоящее время в языке имеется дефект: невозможно описать выражением тип указателя, который получается в результате этой операции. Поэтому в текущей реализации приходится жулничать, используя трюки. Что касается примера, который привдится ниже, то не гарантируется, что он будет работать. Ипользуемый трюк надо локализовать, чтобы программу можно было преобразовать с использованием соответствующей языковой контрукции, когда появится такая возможность. Этот трюк исползует тот факт, что в текущей реализации this реализуется как первый (скрытый) параметр функции члена*:
 – * Более поздние версии С++ поддерживают понятие указтель на член: cl::* означает «указатель на член класса cl». Например:
 typedef void (cl::*PROC)(int); PROC pf1 = amp;cl::print; // приведение к типу ненужно PROC pf2 = amp;cl::print;
 Для вызовов через указатель на функцию член используются операции . и -». Например:
 (z1.*pf1)(2); (( amp;z2)-»*pf2)(4);
 (прим. автора)
 #include «stream.h»
 struct cl (* char* val; void print(int x) (* cout «„ val «« x «« «\n“; *); cl(char* v) (* val = v; *) *);
 // ``фальшивый'' тип для функций членов: typedef void (*PROC)(void*, int);
 main() (* cl z1("z1 "); cl z2("z2 "); PROC pf1 = PROC( amp;z1.print); PROC pf2 = PROC( amp;z2.print); z1.print(1); (*pf1)( amp;z1,2); z2.print(3); (*pf2)( amp;z2,4); *)
 Во многих случаях можно воспользоваться виртуальными функциями (см. Главу 7) там, где иначе пришлось бы использвать указатели на функции.




 5.4.6 Структуры и Объединения


 По определению struct – это просто класс, все члены кторого открытые, то есть
 struct s (* ...
 есть просто сокращенная запись
 class s (* public: ...
 Структуры используются в тех случаях, когда сокрытие данных неуместно.
 Именованное объединение определяется как struct, в котрой все члены имеют один и тот же адрес (см. #с.8.5.13). Если известно, что в каждый момент времени нужно только одно знчение из структуры, то объединение может сэкономить просранство. Например, можно определить объединение для хранения лексических символов C компилятора:
 union tok_val (* char* p; // строка char v[8]; // идентификатор (максимум 8 char) long i; // целые значения double d; // значения с плавающей точкой *);
 Сложность состоит в том, что компилятор, вообще говоря, не знает, какой член используется в каждый данный момент, пэтому надлежащая проверка типа невозможна. Например:
 void strange(int i) (* tok_val x; if (i) x.p = "2"; else x.d = 2; sqrt(x.d); // ошибка если i != 0 *)
 Кроме того, объединение, определенное так, как это, нельзя инициализировать. Например:
 tok_val curr_val = 12; //ошибка:int присваивается tok_val'у
 является недопустимым. Для того, чтобы это преодолеть, можно воспользоваться конструкторами:
 union tok_val (* char* p; // строка char v[8]; // идентификатор (максимум 8 char) long i; // целые значения double d; // значения с плавающей точкой
 tok_val(char*); // должна выбрать между p и v tok_val(int ii) (* i = ii; *) tok_val() (* d = dd; *) *);
 Это позволяет справляться с теми ситуациями, когда типы членов могут быть разрешены по правилам для перегрузки имени функции (см. #4.6.7 и #6.3.3). Например:
 void f() (* tok_val a = 10; // a.i = 10 tok_val b = 10.0; // b.d = 10.0 *)
 Когда это невозможно (для таких типов, как char* и char[8], int и char, и т.п.), нужный член может быть найден только посредством анализа инициализатора в ходе выполнения или с помощью задания дополнительного параметра. Например:
 tok_val::tok_val(char* pp) (* if (strlen(pp) «= 8) strncpy(v,pp,8); // короткая строка else p = pp; // длинная строка *)
 Таких ситуаций вообще-то лучше избегать.
 Использование конструкторов не предохраняет от такого случайного неправильного употребления tok_val, когда сначала
 присваивается значение одного типа, а потом рассматривается как другой тип. Эта проблема решается встраиванием объединния в класс, который отслеживает, какого типа значение помщается:
 class tok_val (* char tag; union (* char* p; char v[8]; long i; double d; *); int check(char t, char* s) (* if (tag!=t) (* error(s); return 0; *) return 1; *) public: tok_val(char* pp); tok_val(long ii) (* i=ii; tag='I'; *) tok_val(double dd) (* d=dd; tag='D'; *)
 long amp; ival() (* check('I',"ival"); return i; *) double amp; fval() (* check('D',"fval"); return d; *) char* amp; sval() (* check('S',"sval"); return p; *) char* id() (* check('N',"id"); return v; *) *);
 Конструктор, получающий строковый параметр, использует для копирования коротких строк strncpy(). strncpy() похожа на strcpy(), но получает третий параметр, который указывает, сколько символов должно копироваться:
 tok_val::tok_val(char* pp) (* if (strlen(pp) «= 8) (* // короткая строка tag = 'N' strncpy(v,pp,8); // скопировать 8 символов *) else (* // длинная строка tag = 'S'; p = pp; // просто сохранить указатель *) *)
 Тип tok_val можно использовать так:
 void f() (* tok_val t1(«short»); // короткая, присвоить v tok_val t2(«long string»); //длинная строка,присвоить p char s[8]; strncpy(s,t1.id(),8); // ok strncpy(s,t2.id(),8); // проверка check() не пройдет *)




 5.5 Конструкторы и Деструкторы


 Если у класса есть конструктор, то он вызывается всегда, когда создается объект класса. Если у класса есть деструктор, то он вызывается всегда, когда объект класса уничтожается. Объекты могут создаваться как:
 1. Автоматический объект: создается каждый раз, когда его описание встречается при выполнении программы, и уничтжается каждый раз при выходе из блока, в котором оно появлось;
 2. Статический объект: создается один раз, при запуске программы, и уничтожается один раз, при ее завершении;
 3. Объект в свободной памяти: создается с помощью опрации new и уничтожается с помощью операции delete;
 4. Объект член: как объект другого класса или как элмент вектора.
 Объект также может быть построен с помощью явного примнения конструктора в выражении (см. #6.4), в этом случае он является автоматическим объектом. В следующих подразделах предполагается, что объекты принадлежат классу, имеющему конструктор и деструктор. Примером может служить класс table из #5.3.




 5.5.1 Предостережение


 Если x и y – объекты класса cl, то x=y в стандартном случае означает побитовое копирование y в x (см. #2.3.8). Ткая интерпретация присваивания может привести к изумляющему (и обычно нежелательному) результату, если оно применяется к объектам класса, для которого определены конструктор и десруктор. Например:
 class char_stack (* int size; char* top; char* s; public: char_stack(int sz) (* top=s=new char[size=sz]; *) ~char_stack() (* delete s; *) // деструктор void push(char c) (* *top++ = c; *) char pop() (* return *–top; *) *);
 void h() (* char_stack s1(100); char_stack s2 = s1; // неприятность char_stack s3(99); s3 = s2; // неприятность *)
 Здесь char_stack::char_stack() вызывается дважды: для s1 и для s3. Для s2 он не вызывается, поскольку эта переменная инициализируется присваиванием. Однако деструктор char_stack::~char_stack() вызывается трижды: для s1, s2 и s3! Кроме того, по умолчанию действует интерпретация присваивания как побитовое копирование, поэтому в конце h() каждый из s1, s2 и s3 будет содержать указатель на вектор символов, размщенный в свободной памяти при создании s1. Не останется никкого указателя на вектор символов, выделенный при создании s3. Таких отклонений можно избежать: см. Главу 6.




 5.5.2 Статическая Память


 Рассмотрим следующее:
 table tbl1(100);
 void f() (* static table tbl2(200); *)
 main() (*
 f(); *)
 Здесь конструктор table::table(), определенный в #5.3.1, будет вызываться дважды: один раз для tbl1 и один раз для tbl2. Деструктор table::~table() также будет вызван дважды: для уничтожения tbl1 и tbl2 после выхода из main(). Конструторы для глобальных статических объектов в файле выполняются в том порядке, в котором встречаются описания; деструкторы вызываются в обратном порядке. Неопределено, вызывается ли конструктор для локального статического объекта, если фунция, в которой этот объект описан, не вызывается. Если контруктор для локального статического объекта вызывается, то он вызывается после того, как вызваны конструкторы для лексичеки предшествующих ему глобальных статических объектов.
 Параметры конструкторов для статических объектов должны быть константными выражениями:
 void g(int a) (* static table t(a); // ошибка *)
 Традиционно выполнением программы считалось выполнение main(). Так никогда не было, даже в C, но только размещение статических объектов класса с конструктором и/или деструктром дают программисту простой и очевидный способ задания тго, что будет выполняться до и/или после вызова main().
 Вызов конструкторов и деструкторов для статических обектов играет в С++ чрезвычайно важную роль. Это способ обеспечить надлежащую инициализацию и очистку структур данных в библиотеках. Рассмотрим «stream.h». Откуда берутся cin, cout и cerr? Где они получают инициализацию? И, что самое главное, поскольку потоки вывода имеют внутренние буферы сиволов, как же эти буферы заполняются? Простой и очевидный овет таков, что эта работа осуществляется соответствующими конструкторами и деструкторами до и после выполнения main(). Для инициализации и очистки библиотечных средств есть возмоности, альтернативные использованию конструкторов и деструторов. Все они или очень специальные, или очень уродливые.
 Если программа завершается с помощью функции exit(), то деструкторы для статических объектов будут вызваны, а если она завершается с помощью abort(), то не будут. Заметьте, что это подразумевает, что exit() не завершает программу мгновено. Вызов exit() в деструкторе может привести к бесконечной рекурсии.
 Иногда, когда вы разрабатываете библиотеку, необходимо или просто удобно создать тип с конструктором и деструктором, предназначенными только для одного: инициализировать и очитить. Такой тип обычно используется только с одной целью, для размещения статического объекта так, чтобы вызывались контруктор и деструктор.




 5.5.3 Свободная Память


 Рассмотрим:
 main() (* table* p = new table(100); table* q = new table(200); delete p; delete p; // возможно, ошибка *)
 Конструктор table::table() будет вызван дважды, как и деструктор table::~table(). То, что С++ не дает никаких грантий, что для объекта, созданного с помощью new, когда-либо будет вызван деструктор, ничего не значит. В предыдущей прорамме q не уничтожается, а p уничтожается дважды! Программист может счесть это ошибкой, а может и не счесть, в зависимости от типа p и q. Обычно то, что объект не уничтожается, являеся не ошибкой, а просто лишней тратой памяти. Уничтожение p дважды будет, как правило, серьезной ошибкой. Обычно резултатом применения delete дважды к одному указателю приводит к бесконечному циклу в подпрограмме управления свободной пмятью, но определение языка не задает поведение в таком слчае, и оно зависит от реализации.
 Пользователь может определить новую реализацию операций new и delete (см. #3.2.6). Можно также определить способ взимодействия конструктора или деструктора с операциями new и delete (см. #5.5.6)




 5.5.4 Объекты Класса как Члены


 Рассмотрим
 class classdef (* table members; int no_of_members; // ... classdef(int size); ~classdef(); *);
 Очевидное намерение состоит в том, что classdef должен содержать таблицу длиной size из членов members, а сложность – в том, как сделать так, чтобы конструктор table::table() вызывался с параметром size. Это делается так:
 classdef::classdef(int size) : members(size) (* no_of_members = size; // ... *)
 Параметры для конструктора члена (здесь это table::table ()) помещаются в определение (не в описание) конструктора класса, вмещающего его (здесь это classdef::classdef()). Поле этого конструктор члена вызывается перед телом конструктра, задающего его список параметров.
 Если есть еще члены, которым нужны списки параметров для конструкторов, их можно задать аналогично. Например:
 class classdef (* table members; table friends; int no_of_members; // ... classdef(int size); ~classdef(); *);
 Список параметров для членов разделяется запятыми (а не двоеточиями), и список инициализаторов для членов может представляться в произвольном порядке:
 classdef::classdef(int size)
 : friends(size), members(size) (* no_of_members = size; // ... *)
 Порядок, в котором вызываются конструкторы, неопределен, поэтому не рекомендуется делать списки параметров с побочными эффектами:
 classdef::classdef(int size) : friends(size=size/2), members(size); // дурной стиль (* no_of_members = size; // ... *)
 Если конструктору для члена не нужно ни одного парамера, то никакого списка параметров задавать не надо. Например, поскольку table::table был определен с параметром по умолчнию 15, следующая запись является правильной:
 classdef::classdef(int size) : members(size) (* no_of_members = size; // ... *)
 и размер size таблицы friends будет равен 15.
 Когда объект класса, содержащий объект класса, (напрмер, classdef) уничтожается, первым выполняется тело собтвенного деструктора объекта, а затем выполняются деструкторы членов.
 Рассмотрим традиционную альтернативу тому, чтобы иметь объекты класса как члены, – иметь члены указатели и инициалзировать их в конструкторе:
 class classdef (* table* members; table* friends; int no_of_members; // ... classdef(int size); ~classdef(); *);
 classdef::classdef(int size) (* members = new table(size); friends = new table; // размер таблицы по умолчанию no_of_members = size; // ... *)
 Так как таблицы создавались с помощью new, они должны уничтожаться с помощью delete:
 classdef::~classdef() (* // ... delete members; delete friends; *)
 Раздельно создаваемые объекты вроде этих могут оказаться полезными, но учтите, что members и friends указывают на одельные объекты, что требует для каждого из них действие по выделению памяти и ее освобождению. Кроме того, указатель плюс объект в свободной памяти занимают больше места, чем объект член.




 5.5.5 Вектора Объектов Класса


 Чтобы описать вектор объектов класса, имеющего конструтор, этот класс должен иметь конструктор, который может вызваться без списка параметров. Нельзя использовать даже парметры по умолчанию. Например:
 table tblvec[10];
 будет ошибкой, так как для table::table() требуется целый параметр. Нет способа задать параметры конструктора в описании вектора. Чтобы можно было описывать вектор таблиц table, можно модифицировать описание table (#5.3.1), напрмер, так:
 class table (* // ... void init(int sz); // как старый конструктор public: table(int sz) // как раньше, но без по умолчанию (* init(sz); *) table() // по умолчанию (* init(15); *) *)
 Когда вектор уничтожается, деструктор должен вызываться для каждого элемента этого вектора. Для векторов, которые не были размещены с помощью new, это делается неявно. Однако для векторов в свободной памяти это не может быть сделано неявно, поскольку компилятор не может отличить указатель на один обект от указателя на первый элемент вектора объектов. Например:
 void f() (* table* t1 = new table; table* t2 = new table[10]; delete t1; // одна таблица delete t2; // неприятность: 10 таблиц *)
 В этом случае длину вектора должен задавать программист:
 void g(int sz) (* table* t1 = new table; table* t2 = new table[sz]; delete t1; delete[] t2; *)
 Но почему же компилятор не может найти число элементов вектора из объема выделенной памяти? Потому, что распределтель свободной памяти не является частью языка и может быть задан программистом.




 5.5.6 Небольшие Объекты


 Когда вы используете много небольших объектов, размещамых в свободной памяти, то вы можете обнаружить, что ваша
 программа тратит много времени выделяя и освобождая память под эти объекты. Первое решение – это обеспечить более хорший распределитель памяти общего назначения, второе для раработчика классов состоит в том, чтобы взять под контроль уравление свободной памятью для объектов некоторого класса с помощью подходящих конструкторов и деструкторов.
 Рассмотрим класс name, который использовался в примерах table. Его можно было бы определить так:
 struct name (* char* string; name* next; double value;
 name(char*, double, name*); ~name(); *);
 Программист может воспользоваться тем, что размещение и освобождение объектов заранее известного размера можно обрбатывать гораздо эффективнее (и по памяти, и по времени), чем с помощью общей реализации new и delete. Общая идея состоит в том, чтобы предварительно разместить «куски» из объектов name, а затем сцеплять их, чтобы свести выделение и освободение к простым операциям над связанным списком. Переменная nfree является вершиной списка неиспользованных name:
 const NALL = 128; name* nfree;
 Распределитель, используемый операцией new, хранит рамер объекта вместе с объектом, чтобы обеспечить правильную работу операции delete. С помощью распределителя, специализрованного для типа, можно избежать этих накладных расходов. Например, на моей машине следующий распределитель использует для хранения name 16 байт, тогда как для стандартного распрделителя свободной памяти нужно 20 байт. Вот как это можно сделать:
 name::name(char* s, double v, name* n) (* register name* p = nfree; // сначала выделить
 if (p) nfree = p-»next; else (* // выделить и сцепить name* q = (name*)new char[ NALL*sizeof(name) ]; for (p=nfree= amp;q[NALL-1]; q«p; p–) p-»next = p-1; (p+1)-»next = 0; *)
 this = p; // затем инициализировать string = s; value = v; next = n; *)
 Присвоение указателю this информирует компилятор о том, что программист взял себе управление, и что не надо использвать стандартный механизм распределения памяти. Конструктор name::name() обрабатывает только тот случай, когда name рамещается посредством new, но для большей части типов это всегда так. В #5.5.8 объясняется, как написать конструктор для обработки как размещения в свободной памяти, так и других видов размещения.
 Заметьте, что просто как
 name* q = new name[NALL];
 память выделять нельзя, поскольку это приведет к бескнечной рекурсии, когда new вызовет name::name().
 Освобождение памяти обычно тривиально:
 name::~name() (* next = nfree; nfree = this; this = 0; *)
 Присваивание указателю this 0 в деструкторе обеспечивет, что стандартный распределитель памяти не используется.




 5.5.7 Предостережение


 Когда в конструкторе производится указателю this, значние this до этого присваивания неопределено. Таким образом, ссылка на член до этого присваивания неопределена и скорее всего приведет к катастрофе. Имеющийся компилятор не пытается убедиться в том, что присваивание указателю this происходит на всех траекториях выполнения:
 mytype::mytype(int i) (* if (i) this = mytype_alloc(); // присваивание членам *);
 откомпилируется, и при i==0 никакой объект размещен не будет.
 Конструктор может определить, был ли он вызван операцией new, или нет. Если он вызван new, то указатель this на входе имеет нулевое значение, в противном случае this указывает на пространство, уже выделенное для объекта (например, на стек). Поэтому можно просто написать конструктор, который выделяет память, если (и только если) он был вызван через new. Напрмер:
 mytype::mytype(int i) (* if (this == 0) this = mytype_alloc(); // присваивание членам *);
 Эквивалентного средства, которое позволяет деструктору решить вопрос, был ли его объект создан с помощью new, не имеется, как нет и средства, позволяющего ему узнать, вызвала ли его delete, или он вызван объектом, выходящим из области видимости. Если для пользователя это существенно, то он может сохранить где-то соответствующую информацию для деструктора. Другой способ – когда пользователь обеспечивает, что объекты этого класса размещаются только соответствующим образом. Если удается справиться с первой проблемой, то второй способ интреса не представляет.
 Если тот, кто реализует класс, является одновременно и его единственным пользователем, то имеет смысл упростить класс, исходя из предположений о его использовании. Когда класс разрабатывается для более широкого использования, таких допущений, как правило, лучше избегать.




 5.5.8 Объекты Переменного Размера


 Когда пользователь берет управление распределением и овобождением памяти, он может конструировать объекты размеры, которых во время компиляции недетерминирован. В предыдущих примерах вмещающие (или контейнерные – перев.) классы vector, stack, intset и table реализовывались как структуры доступа фиксированного размера, содержащие указатели на реальную пмять. Это подразумевает, что для создания таких объектов в свободной памяти необходимо две операции по выделению памяти, и что любое обращение к хранимой информации будет содержать дополнительную косвенную адресацию. Например:
 class char_stack (* int size; char* top; char* s; public: char_stack(int sz) (* top=s=new char[size=sz]; *) ~char_stack() (* delete s; *) // деструктор void push(char c) (* *top++ = c; *) char pop() (* return *–top; *) *);
 Если каждый объект класса размещается в свободной памти, это делать не нужно. Вот другой вариант:
 class char_stack (* int size; char* top; char s[1]; public: char_stack(int sz); void push(char c) (* *top++ = c; *) char pop() (* return *–top; *) *);
 char_stack::char_stack(int sz) (* if (this) error(«стек не в свободной памяти»); if (sz « 1) error(„размер стека « 1“); this = (char_stack*) new char[sizeof(char_stack)+sz-1]; size = sz; top = s; *)
 Заметьте, что деструктор больше не нужен, поскольку пмять, которую использует char_stack, может освободить delete без всякого содействия со стороны программиста.




 5.6 Упражнения


 1. (*1) Модифицируйте настольный калькулятор из Главы 3, чтобы использовать класс table.
 2. (*1) Разработайте tnode (#с.8.5) как класс с контрукторами, деструкторами и т.п. Определите дерево из tnode'ов как класс с конструкторами, деструкторами и т.п.
 3. (*1) Преобразуйте класс intset (#5.3.2) в множество строк.
 4. (*1) Преобразуйте класс intset в множество узлов node, где node – определяемая вами структура.
 5. (*3) Определите класс для анализа, хранения, вычислния и печати простых арифметических выражений, состоящих из целых констант и операций +, -, * и /. Открытый итерфейс должен выглядеть примерно так:
 class expr (* // ... public: expr(char*); int eval(); void print(); *) Параметр строка конструктора expr::expr() является выржением. Функция expr::eval() возвращает значение выражния, а expr::print() печатает представление выражения в cout. Программа может выглядеть, например, так:
 expr x(«123/4+123*4-3»); cout «„ "x = " «« x.eval() «« «\n“; x.print();
 Определите класс expr два раза: один раз используя в кчестве представления связанный список узлов, а другой раз – символьную строку. Поэкспериментируйте с разными способами печати выражения: с полностью расставленными скобками,в постфиксной записи,в ассемблерном коде и т.д.
 6. (*1) Определите класс char_queue (символьная очередь) таким образом, чтобы открытый интерфейс не зависел от представления. Реализуйте char_queue как (1) связанный список и как (2) вектор. О согласованности не заботтесь.
 7. (*2) Определите класс histogram (гистограмма), в ктором ведется подсчет чисел в определенных интервалах, которые задаются как параметры конструктора histogram. Обеспечьте функцию вывода гистограммы на печать. Сделате обработку значений, выходящих за границы. Подсказка: «task.h».
 8. (*2) Определите несколько классов, предоставляющих случайные числа с определенными распределениями. Каждый класс имеет конструктор, задающий параметры распределния, и функцию draw, которая возвращает «следующее» знчение. Подсказка: «task.h». Посмотрите также класс intset.
 9. (*2) Перепишите пример date (#5.8.2), пример char_stack (#5.2.5) и пример intset (#5.3.2) не исползуя функций членов (даже конструкторов и деструкторов). Используйте только class и friend. Сравните с версиями, в которых использовались функции члены.
 10. (*3) Для какого-нибудь языка спроектируйте класс таблица имен и класс вхождение в таблицу имен. Чтобы посмотреть, как на самом деле выглядит таблица имен, посмотрите на компилятор этого языка.
 11. (*2) Модифицируйте класс выражение из Упражнения 5 так, чтобы обрабатывать переменные и операцию присваивния =. Используйте класс таблица имен из Упражнения 10.
 12. (*1) Дана программа:
 #include «stream.h»
 main() (* cout «„ «Hello, world\n“; *)
 модифицируйте ее, чтобы получить выдачу
 Initialize Hello, world Clean up
 Не делайте никаких изменений в main().